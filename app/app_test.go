package app

// TODO: add tests below with thorchain's setup (non-typical cosmos chain)

import (
	"crypto/ecdsa"
	"testing"

	"cosmossdk.io/log"
	"cosmossdk.io/math"
	wasmkeeper "github.com/CosmWasm/wasmd/x/wasm/keeper"
	dbm "github.com/cosmos/cosmos-db"
	"github.com/cosmos/cosmos-sdk/client/tx"
	simtestutil "github.com/cosmos/cosmos-sdk/testutil/sims"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/msgservice"
	"github.com/cosmos/cosmos-sdk/types/tx/signing"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	"github.com/cosmos/evm/crypto/ethsecp256k1"
	"github.com/cosmos/evm/ethereum/eip712"
	"github.com/cosmos/gogoproto/proto"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/require"
	thorchain "gitlab.com/thorchain/thornode/v3/common"
	"gitlab.com/thorchain/thornode/v3/common/cosmos"
)

// func TestAppExport(t *testing.T) {
// 	cfg := sdk.GetConfig()
// 	cfg.SetBech32PrefixForAccount("thor", "thorpub")
// 	cfg.SetBech32PrefixForValidator("thorv", "thorvpub")
// 	cfg.SetBech32PrefixForConsensusNode("thorc", "thorcpub")
// 	cfg.SetCoinType(931)
// 	cfg.SetPurpose(44)
// 	cfg.Seal()
// 	sdk.SetCoinDenomRegex(func() string {
// 		return `[a-zA-Z][a-zA-Z0-9:\\/\\\-\\_\\.]{2,127}`
// 	})

// 	db := dbm.NewMemDB()
// 	logger := log.NewTestLogger(t)
// 	gapp := NewChainAppWithCustomOptions(t, false, SetupOptions{
// 		Logger:  logger.With("instance", "first"),
// 		DB:      db,
// 		AppOpts: simtestutil.NewAppOptionsWithFlagHome(t.TempDir()),
// 	})

// 	// finalize block so we have CheckTx state set
// 	_, err := gapp.FinalizeBlock(&abci.RequestFinalizeBlock{
// 		Height: 1,
// 	})
// 	require.NoError(t, err)

// 	_, err = gapp.Commit()
// 	require.NoError(t, err)

// 	// Making a new app object with the db, so that initchain hasn't been called
// 	newGapp := NewChainApp(
// 		logger, db, nil, true, simtestutil.NewAppOptionsWithFlagHome(t.TempDir()),
// 	)
// 	_, err = newGapp.ExportAppStateAndValidators(false, []string{}, nil)
// 	require.NoError(t, err, "ExportAppStateAndValidators should not have an error")
// }

// // ensure that blocked addresses are properly set in bank keeper
// func TestBlockedAddrs(t *testing.T) {
// 	gapp := Setup(t)

// 	for acc := range BlockedAddresses() {
// 		t.Run(acc, func(t *testing.T) {
// 			var addr sdk.AccAddress
// 			if modAddr, err := sdk.AccAddressFromBech32(acc); err == nil {
// 				addr = modAddr
// 			} else {
// 				addr = gapp.AccountKeeper.GetModuleAddress(acc)
// 			}
// 			require.True(t, gapp.BankKeeper.BlockedAddr(addr), "ensure that blocked addresses are properly set in bank keeper")
// 		})
// 	}
// }

func TestGetMaccPerms(t *testing.T) {
	dup := GetMaccPerms()
	require.Equal(t, maccPerms, dup, "duplicated module account permissions differed from actual module account permissions")
}

// TestMergedRegistry tests that fetching the gogo/protov2 merged registry
// doesn't fail after loading all file descriptors.
func TestMergedRegistry(t *testing.T) {
	r, err := proto.MergedRegistry()
	require.NoError(t, err)
	require.Greater(t, r.NumFiles(), 0)
}

func TestProtoAnnotations(t *testing.T) {
	r, err := proto.MergedRegistry()
	require.NoError(t, err)
	err = msgservice.ValidateProtoAnnotations(r)
	require.NoError(t, err)
}

// End-to-end test to verify:
// 1. create go-ethereum keypair & address
// 2. encode address to bech32 with address.go mapping
// 3. construct a SignDoc and translate it into EIP-712 TypedData
// 4. sign TypedData with original keypair
// 5. validate signature on ethsecp256k1 keypair
func TestEip712Signing(t *testing.T) {
	// Initialize app to ensure all codecs are registered
	NewChainApp(
		log.NewNopLogger(),
		dbm.NewMemDB(),
		nil,
		false,
		simtestutil.EmptyAppOptions{},
		[]wasmkeeper.Option{},
	)

	// 1.
	ethPrivateKey, err := crypto.GenerateKey()
	require.NoError(t, err)
	ethPublicKey, ok := ethPrivateKey.Public().(*ecdsa.PublicKey)
	require.True(t, ok)
	ethAddress := crypto.PubkeyToAddress(*ethPublicKey).Hex()

	// 2.
	address, err := thorchain.NewAddress(ethAddress)
	require.NoError(t, err)
	cosmosAddress, err := address.MappedAccAddress()
	require.NoError(t, err)
	cosmosKey := ethsecp256k1.PrivKey{Key: crypto.FromECDSA(ethPrivateKey)}

	// Check that the mapped address is the same as the address generated by
	// the ethsecp256k1 PrivKey
	require.Equal(t,
		cosmosAddress.String(),
		sdk.AccAddress(cosmosKey.PubKey().Address()).String(),
	)

	// 3
	msg := banktypes.NewMsgSend(
		sdk.AccAddress(cosmosKey.PubKey().Address()),
		sdk.AccAddress(cosmosKey.PubKey().Address()),
		cosmos.NewCoins(cosmos.NewCoin("rune", math.NewInt(1000))),
	)
	builder := tx.NewAuxTxBuilder()
	builder.SetAddress(cosmosKey.PubKey().Address().String())
	err = builder.SetPubKey(cosmosKey.PubKey())
	require.NoError(t, err)
	builder.SetAccountNumber(123)
	builder.SetSequence(456)
	builder.SetChainID("thorchain")
	err = builder.SetSignMode(signing.SignMode_SIGN_MODE_LEGACY_AMINO_JSON)
	require.NoError(t, err)
	err = builder.SetMsgs(msg)
	require.NoError(t, err)
	signBytes, err := builder.GetSignBytes()
	require.NoError(t, err)

	// 4
	eip712Bytes, err := eip712.GetEIP712BytesForMsg(signBytes)
	require.NoError(t, err)
	digest := crypto.Keccak256(eip712Bytes)
	signature, err := crypto.Sign(digest, ethPrivateKey)
	require.NoError(t, err)

	// 5
	valid := cosmosKey.PubKey().VerifySignature(eip712Bytes, signature)
	require.True(t, valid)
}

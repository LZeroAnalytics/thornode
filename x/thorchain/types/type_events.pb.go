// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/type_events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	common "gitlab.com/thorchain/thornode/v3/common"
	gitlab_com_thorchain_thornode_v3_common "gitlab.com/thorchain/thornode/v3/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PendingLiquidityType int32

const (
	PendingLiquidityType_add      PendingLiquidityType = 0
	PendingLiquidityType_withdraw PendingLiquidityType = 1
)

var PendingLiquidityType_name = map[int32]string{
	0: "add",
	1: "withdraw",
}

var PendingLiquidityType_value = map[string]int32{
	"add":      0,
	"withdraw": 1,
}

func (x PendingLiquidityType) String() string {
	return proto.EnumName(PendingLiquidityType_name, int32(x))
}

func (PendingLiquidityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{0}
}

type BondType int32

const (
	BondType_bond_paid     BondType = 0
	BondType_bond_returned BondType = 1
	BondType_bond_reward   BondType = 2
	BondType_bond_cost     BondType = 3
)

var BondType_name = map[int32]string{
	0: "bond_paid",
	1: "bond_returned",
	2: "bond_reward",
	3: "bond_cost",
}

var BondType_value = map[string]int32{
	"bond_paid":     0,
	"bond_returned": 1,
	"bond_reward":   2,
	"bond_cost":     3,
}

func (x BondType) String() string {
	return proto.EnumName(BondType_name, int32(x))
}

func (BondType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{1}
}

type MintBurnSupplyType int32

const (
	MintBurnSupplyType_mint MintBurnSupplyType = 0
	MintBurnSupplyType_burn MintBurnSupplyType = 1
)

var MintBurnSupplyType_name = map[int32]string{
	0: "mint",
	1: "burn",
}

var MintBurnSupplyType_value = map[string]int32{
	"mint": 0,
	"burn": 1,
}

func (x MintBurnSupplyType) String() string {
	return proto.EnumName(MintBurnSupplyType_name, int32(x))
}

func (MintBurnSupplyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{2}
}

type PoolMod struct {
	Asset    gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
	RuneAmt  cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amt"`
	RuneAdd  bool                                          `protobuf:"varint,3,opt,name=rune_add,json=runeAdd,proto3" json:"rune_add,omitempty"`
	AssetAmt cosmossdk_io_math.Uint                        `protobuf:"bytes,4,opt,name=asset_amt,json=assetAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amt"`
	AssetAdd bool                                          `protobuf:"varint,5,opt,name=asset_add,json=assetAdd,proto3" json:"asset_add,omitempty"`
}

func (m *PoolMod) Reset()         { *m = PoolMod{} }
func (m *PoolMod) String() string { return proto.CompactTextString(m) }
func (*PoolMod) ProtoMessage()    {}
func (*PoolMod) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{0}
}
func (m *PoolMod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMod.Merge(m, src)
}
func (m *PoolMod) XXX_Size() int {
	return m.Size()
}
func (m *PoolMod) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMod.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMod proto.InternalMessageInfo

func (m *PoolMod) GetRuneAdd() bool {
	if m != nil {
		return m.RuneAdd
	}
	return false
}

func (m *PoolMod) GetAssetAdd() bool {
	if m != nil {
		return m.AssetAdd
	}
	return false
}

type EventLimitSwap struct {
	Source common.Coin                                  `protobuf:"bytes,1,opt,name=source,proto3" json:"source"`
	Target common.Coin                                  `protobuf:"bytes,2,opt,name=target,proto3" json:"target"`
	TxID   gitlab_com_thorchain_thornode_v3_common.TxID `protobuf:"bytes,3,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLimitSwap) Reset()         { *m = EventLimitSwap{} }
func (m *EventLimitSwap) String() string { return proto.CompactTextString(m) }
func (*EventLimitSwap) ProtoMessage()    {}
func (*EventLimitSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{1}
}
func (m *EventLimitSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLimitSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLimitSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLimitSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLimitSwap.Merge(m, src)
}
func (m *EventLimitSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventLimitSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLimitSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventLimitSwap proto.InternalMessageInfo

func (m *EventLimitSwap) GetSource() common.Coin {
	if m != nil {
		return m.Source
	}
	return common.Coin{}
}

func (m *EventLimitSwap) GetTarget() common.Coin {
	if m != nil {
		return m.Target
	}
	return common.Coin{}
}

func (m *EventLimitSwap) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventModifyLimitSwap struct {
	From                 gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,1,opt,name=from,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"from,omitempty"`
	Source               common.Coin                                     `protobuf:"bytes,2,opt,name=source,proto3" json:"source"`
	Target               common.Coin                                     `protobuf:"bytes,3,opt,name=target,proto3" json:"target"`
	ModifiedTargetAmount cosmossdk_io_math.Uint                          `protobuf:"bytes,4,opt,name=modified_target_amount,json=modifiedTargetAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"modified_target_amount"`
}

func (m *EventModifyLimitSwap) Reset()         { *m = EventModifyLimitSwap{} }
func (m *EventModifyLimitSwap) String() string { return proto.CompactTextString(m) }
func (*EventModifyLimitSwap) ProtoMessage()    {}
func (*EventModifyLimitSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{2}
}
func (m *EventModifyLimitSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModifyLimitSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModifyLimitSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModifyLimitSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModifyLimitSwap.Merge(m, src)
}
func (m *EventModifyLimitSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventModifyLimitSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModifyLimitSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventModifyLimitSwap proto.InternalMessageInfo

func (m *EventModifyLimitSwap) GetFrom() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventModifyLimitSwap) GetSource() common.Coin {
	if m != nil {
		return m.Source
	}
	return common.Coin{}
}

func (m *EventModifyLimitSwap) GetTarget() common.Coin {
	if m != nil {
		return m.Target
	}
	return common.Coin{}
}

type EventStreamingSwap struct {
	TxID              gitlab_com_thorchain_thornode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
	Interval          uint64                                       `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Quantity          uint64                                       `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Count             uint64                                       `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	LastHeight        int64                                        `protobuf:"varint,5,opt,name=last_height,json=lastHeight,proto3" json:"last_height,omitempty"`
	TradeTarget       cosmossdk_io_math.Uint                       `protobuf:"bytes,6,opt,name=trade_target,json=tradeTarget,proto3,customtype=cosmossdk.io/math.Uint" json:"trade_target"`
	Deposit           common.Coin                                  `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit"`
	In                common.Coin                                  `protobuf:"bytes,8,opt,name=in,proto3" json:"in"`
	Out               common.Coin                                  `protobuf:"bytes,9,opt,name=out,proto3" json:"out"`
	FailedSwaps       []uint64                                     `protobuf:"varint,10,rep,packed,name=failed_swaps,json=failedSwaps,proto3" json:"failed_swaps,omitempty"`
	FailedSwapReasons []string                                     `protobuf:"bytes,11,rep,name=failed_swap_reasons,json=failedSwapReasons,proto3" json:"failed_swap_reasons,omitempty"`
}

func (m *EventStreamingSwap) Reset()         { *m = EventStreamingSwap{} }
func (m *EventStreamingSwap) String() string { return proto.CompactTextString(m) }
func (*EventStreamingSwap) ProtoMessage()    {}
func (*EventStreamingSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{3}
}
func (m *EventStreamingSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStreamingSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStreamingSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStreamingSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStreamingSwap.Merge(m, src)
}
func (m *EventStreamingSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventStreamingSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStreamingSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventStreamingSwap proto.InternalMessageInfo

func (m *EventStreamingSwap) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventStreamingSwap) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *EventStreamingSwap) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *EventStreamingSwap) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *EventStreamingSwap) GetLastHeight() int64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (m *EventStreamingSwap) GetDeposit() common.Coin {
	if m != nil {
		return m.Deposit
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetIn() common.Coin {
	if m != nil {
		return m.In
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetOut() common.Coin {
	if m != nil {
		return m.Out
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetFailedSwaps() []uint64 {
	if m != nil {
		return m.FailedSwaps
	}
	return nil
}

func (m *EventStreamingSwap) GetFailedSwapReasons() []string {
	if m != nil {
		return m.FailedSwapReasons
	}
	return nil
}

type EventSwap struct {
	Pool                  gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	SwapTarget            cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=swap_target,json=swapTarget,proto3,customtype=cosmossdk.io/math.Uint" json:"swap_target"`
	SwapSlip              cosmossdk_io_math.Uint                        `protobuf:"bytes,3,opt,name=swap_slip,json=swapSlip,proto3,customtype=cosmossdk.io/math.Uint" json:"swap_slip"`
	LiquidityFee          cosmossdk_io_math.Uint                        `protobuf:"bytes,4,opt,name=liquidity_fee,json=liquidityFee,proto3,customtype=cosmossdk.io/math.Uint" json:"liquidity_fee"`
	LiquidityFeeInRune    cosmossdk_io_math.Uint                        `protobuf:"bytes,5,opt,name=liquidity_fee_in_rune,json=liquidityFeeInRune,proto3,customtype=cosmossdk.io/math.Uint" json:"liquidity_fee_in_rune"`
	InTx                  common.Tx                                     `protobuf:"bytes,6,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	OutTxs                common.Tx                                     `protobuf:"bytes,7,opt,name=out_txs,json=outTxs,proto3" json:"out_txs"`
	EmitAsset             common.Coin                                   `protobuf:"bytes,8,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset"`
	SynthUnits            cosmossdk_io_math.Uint                        `protobuf:"bytes,9,opt,name=synth_units,json=synthUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"synth_units"`
	StreamingSwapQuantity uint64                                        `protobuf:"varint,10,opt,name=streaming_swap_quantity,json=streamingSwapQuantity,proto3" json:"streaming_swap_quantity,omitempty"`
	StreamingSwapCount    uint64                                        `protobuf:"varint,11,opt,name=streaming_swap_count,json=streamingSwapCount,proto3" json:"streaming_swap_count,omitempty"`
	PoolSlip              cosmossdk_io_math.Uint                        `protobuf:"bytes,12,opt,name=pool_slip,json=poolSlip,proto3,customtype=cosmossdk.io/math.Uint" json:"pool_slip"`
}

func (m *EventSwap) Reset()         { *m = EventSwap{} }
func (m *EventSwap) String() string { return proto.CompactTextString(m) }
func (*EventSwap) ProtoMessage()    {}
func (*EventSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{4}
}
func (m *EventSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwap.Merge(m, src)
}
func (m *EventSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwap proto.InternalMessageInfo

func (m *EventSwap) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventSwap) GetOutTxs() common.Tx {
	if m != nil {
		return m.OutTxs
	}
	return common.Tx{}
}

func (m *EventSwap) GetEmitAsset() common.Coin {
	if m != nil {
		return m.EmitAsset
	}
	return common.Coin{}
}

func (m *EventSwap) GetStreamingSwapQuantity() uint64 {
	if m != nil {
		return m.StreamingSwapQuantity
	}
	return 0
}

func (m *EventSwap) GetStreamingSwapCount() uint64 {
	if m != nil {
		return m.StreamingSwapCount
	}
	return 0
}

type EventAffiliateFee struct {
	TxID        gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
	Memo        string                                          `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	Thorname    string                                          `protobuf:"bytes,3,opt,name=thorname,proto3" json:"thorname,omitempty"`
	RuneAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	Asset       gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,5,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
	GrossAmount cosmossdk_io_math.Uint                          `protobuf:"bytes,6,opt,name=gross_amount,json=grossAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"gross_amount"`
	FeeBps      uint64                                          `protobuf:"varint,7,opt,name=fee_bps,json=feeBps,proto3" json:"fee_bps,omitempty"`
	FeeAmount   cosmossdk_io_math.Uint                          `protobuf:"bytes,8,opt,name=fee_amount,json=feeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"fee_amount"`
}

func (m *EventAffiliateFee) Reset()         { *m = EventAffiliateFee{} }
func (m *EventAffiliateFee) String() string { return proto.CompactTextString(m) }
func (*EventAffiliateFee) ProtoMessage()    {}
func (*EventAffiliateFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{5}
}
func (m *EventAffiliateFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAffiliateFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAffiliateFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAffiliateFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAffiliateFee.Merge(m, src)
}
func (m *EventAffiliateFee) XXX_Size() int {
	return m.Size()
}
func (m *EventAffiliateFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAffiliateFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventAffiliateFee proto.InternalMessageInfo

func (m *EventAffiliateFee) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventAffiliateFee) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *EventAffiliateFee) GetThorname() string {
	if m != nil {
		return m.Thorname
	}
	return ""
}

func (m *EventAffiliateFee) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventAffiliateFee) GetFeeBps() uint64 {
	if m != nil {
		return m.FeeBps
	}
	return 0
}

type EventAddLiquidity struct {
	Pool          gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	ProviderUnits cosmossdk_io_math.Uint                          `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"provider_units"`
	RuneAddress   gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	RuneAmount    cosmossdk_io_math.Uint                          `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amount"`
	AssetAmount   cosmossdk_io_math.Uint                          `protobuf:"bytes,5,opt,name=asset_amount,json=assetAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amount"`
	RuneTxID      gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,6,opt,name=rune_tx_id,json=runeTxId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"rune_tx_id,omitempty"`
	AssetTxID     gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,7,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"asset_tx_id,omitempty"`
	AssetAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,8,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
}

func (m *EventAddLiquidity) Reset()         { *m = EventAddLiquidity{} }
func (m *EventAddLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventAddLiquidity) ProtoMessage()    {}
func (*EventAddLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{6}
}
func (m *EventAddLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAddLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAddLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAddLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAddLiquidity.Merge(m, src)
}
func (m *EventAddLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventAddLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAddLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventAddLiquidity proto.InternalMessageInfo

func (m *EventAddLiquidity) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventAddLiquidity) GetRuneTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

type EventWithdraw struct {
	Pool          gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	ProviderUnits cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"provider_units"`
	BasisPoints   int64                                         `protobuf:"varint,3,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	Asymmetry     cosmossdk_io_math.LegacyDec                   `protobuf:"bytes,4,opt,name=asymmetry,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"asymmetry"`
	InTx          common.Tx                                     `protobuf:"bytes,5,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	EmitAsset     cosmossdk_io_math.Uint                        `protobuf:"bytes,6,opt,name=emit_asset,json=emitAsset,proto3,customtype=cosmossdk.io/math.Uint" json:"emit_asset"`
	EmitRune      cosmossdk_io_math.Uint                        `protobuf:"bytes,7,opt,name=emit_rune,json=emitRune,proto3,customtype=cosmossdk.io/math.Uint" json:"emit_rune"`
}

func (m *EventWithdraw) Reset()         { *m = EventWithdraw{} }
func (m *EventWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventWithdraw) ProtoMessage()    {}
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{7}
}
func (m *EventWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdraw.Merge(m, src)
}
func (m *EventWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdraw proto.InternalMessageInfo

func (m *EventWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventWithdraw) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPendingLiquidity struct {
	Pool         gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	PendingType  PendingLiquidityType                            `protobuf:"varint,2,opt,name=pending_type,json=pendingType,proto3,enum=types.PendingLiquidityType" json:"pending_type,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	RuneAmount   cosmossdk_io_math.Uint                          `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amount"`
	AssetAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,5,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
	AssetAmount  cosmossdk_io_math.Uint                          `protobuf:"bytes,6,opt,name=asset_amount,json=assetAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amount"`
	RuneTxID     gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,7,opt,name=rune_tx_id,json=runeTxId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"rune_tx_id,omitempty"`
	AssetTxID    gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,8,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"asset_tx_id,omitempty"`
}

func (m *EventPendingLiquidity) Reset()         { *m = EventPendingLiquidity{} }
func (m *EventPendingLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventPendingLiquidity) ProtoMessage()    {}
func (*EventPendingLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{8}
}
func (m *EventPendingLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPendingLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPendingLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPendingLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPendingLiquidity.Merge(m, src)
}
func (m *EventPendingLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventPendingLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPendingLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventPendingLiquidity proto.InternalMessageInfo

func (m *EventPendingLiquidity) GetPendingType() PendingLiquidityType {
	if m != nil {
		return m.PendingType
	}
	return PendingLiquidityType_add
}

func (m *EventPendingLiquidity) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetRuneTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

type EventDonate struct {
	Pool gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	InTx common.Tx                                     `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventDonate) Reset()         { *m = EventDonate{} }
func (m *EventDonate) String() string { return proto.CompactTextString(m) }
func (*EventDonate) ProtoMessage()    {}
func (*EventDonate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{9}
}
func (m *EventDonate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDonate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDonate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDonate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDonate.Merge(m, src)
}
func (m *EventDonate) XXX_Size() int {
	return m.Size()
}
func (m *EventDonate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDonate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDonate proto.InternalMessageInfo

func (m *EventDonate) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPool struct {
	Pool   gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	Status PoolStatus                                    `protobuf:"varint,2,opt,name=Status,proto3,enum=types.PoolStatus" json:"Status,omitempty"`
}

func (m *EventPool) Reset()         { *m = EventPool{} }
func (m *EventPool) String() string { return proto.CompactTextString(m) }
func (*EventPool) ProtoMessage()    {}
func (*EventPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{10}
}
func (m *EventPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPool.Merge(m, src)
}
func (m *EventPool) XXX_Size() int {
	return m.Size()
}
func (m *EventPool) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPool.DiscardUnknown(m)
}

var xxx_messageInfo_EventPool proto.InternalMessageInfo

func (m *EventPool) GetStatus() PoolStatus {
	if m != nil {
		return m.Status
	}
	return PoolStatus_UnknownPoolStatus
}

type PoolAmt struct {
	Asset  gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
	Amount int64                                         `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *PoolAmt) Reset()         { *m = PoolAmt{} }
func (m *PoolAmt) String() string { return proto.CompactTextString(m) }
func (*PoolAmt) ProtoMessage()    {}
func (*PoolAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{11}
}
func (m *PoolAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAmt.Merge(m, src)
}
func (m *PoolAmt) XXX_Size() int {
	return m.Size()
}
func (m *PoolAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAmt.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAmt proto.InternalMessageInfo

func (m *PoolAmt) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type EventRewards struct {
	BondReward     cosmossdk_io_math.Uint `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3,customtype=cosmossdk.io/math.Uint" json:"bond_reward"`
	PoolRewards    []PoolAmt              `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards"`
	DevFundReward  cosmossdk_io_math.Uint `protobuf:"bytes,3,opt,name=dev_fund_reward,json=devFundReward,proto3,customtype=cosmossdk.io/math.Uint" json:"dev_fund_reward"`
	IncomeBurn     cosmossdk_io_math.Uint `protobuf:"bytes,4,opt,name=income_burn,json=incomeBurn,proto3,customtype=cosmossdk.io/math.Uint" json:"income_burn"`
	TcyStakeReward cosmossdk_io_math.Uint `protobuf:"bytes,5,opt,name=tcy_stake_reward,json=tcyStakeReward,proto3,customtype=cosmossdk.io/math.Uint" json:"tcy_stake_reward"`
}

func (m *EventRewards) Reset()         { *m = EventRewards{} }
func (m *EventRewards) String() string { return proto.CompactTextString(m) }
func (*EventRewards) ProtoMessage()    {}
func (*EventRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{12}
}
func (m *EventRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRewards.Merge(m, src)
}
func (m *EventRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventRewards proto.InternalMessageInfo

func (m *EventRewards) GetPoolRewards() []PoolAmt {
	if m != nil {
		return m.PoolRewards
	}
	return nil
}

type EventRefund struct {
	Code   uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	InTx   common.Tx  `protobuf:"bytes,3,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	Fee    common.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee"`
}

func (m *EventRefund) Reset()         { *m = EventRefund{} }
func (m *EventRefund) String() string { return proto.CompactTextString(m) }
func (*EventRefund) ProtoMessage()    {}
func (*EventRefund) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{13}
}
func (m *EventRefund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRefund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRefund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRefund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRefund.Merge(m, src)
}
func (m *EventRefund) XXX_Size() int {
	return m.Size()
}
func (m *EventRefund) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRefund.DiscardUnknown(m)
}

var xxx_messageInfo_EventRefund proto.InternalMessageInfo

func (m *EventRefund) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EventRefund) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventRefund) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventRefund) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventBond struct {
	Amount      cosmossdk_io_math.Uint                        `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	BondType    BondType                                      `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn        common.Tx                                     `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,4,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	BondAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,5,opt,name=bond_address,json=bondAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"bond_address,omitempty"`
}

func (m *EventBond) Reset()         { *m = EventBond{} }
func (m *EventBond) String() string { return proto.CompactTextString(m) }
func (*EventBond) ProtoMessage()    {}
func (*EventBond) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{14}
}
func (m *EventBond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBond.Merge(m, src)
}
func (m *EventBond) XXX_Size() int {
	return m.Size()
}
func (m *EventBond) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBond.DiscardUnknown(m)
}

var xxx_messageInfo_EventBond proto.InternalMessageInfo

func (m *EventBond) GetBondType() BondType {
	if m != nil {
		return m.BondType
	}
	return BondType_bond_paid
}

func (m *EventBond) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

func (m *EventBond) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventBond) GetBondAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.BondAddress
	}
	return nil
}

type EventReBond struct {
	Amount         cosmossdk_io_math.Uint                        `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	TxIn           common.Tx                                     `protobuf:"bytes,2,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
	NodeAddress    github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	OldBondAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,4,opt,name=old_bond_address,json=oldBondAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"old_bond_address,omitempty"`
	NewBondAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,5,opt,name=new_bond_address,json=newBondAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"new_bond_address,omitempty"`
}

func (m *EventReBond) Reset()         { *m = EventReBond{} }
func (m *EventReBond) String() string { return proto.CompactTextString(m) }
func (*EventReBond) ProtoMessage()    {}
func (*EventReBond) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{15}
}
func (m *EventReBond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReBond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReBond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReBond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReBond.Merge(m, src)
}
func (m *EventReBond) XXX_Size() int {
	return m.Size()
}
func (m *EventReBond) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReBond.DiscardUnknown(m)
}

var xxx_messageInfo_EventReBond proto.InternalMessageInfo

func (m *EventReBond) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

func (m *EventReBond) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventReBond) GetOldBondAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.OldBondAddress
	}
	return nil
}

func (m *EventReBond) GetNewBondAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NewBondAddress
	}
	return nil
}

type GasPool struct {
	Asset    gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
	RuneAmt  cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amt"`
	AssetAmt cosmossdk_io_math.Uint                        `protobuf:"bytes,3,opt,name=asset_amt,json=assetAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"asset_amt"`
	Count    int64                                         `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GasPool) Reset()         { *m = GasPool{} }
func (m *GasPool) String() string { return proto.CompactTextString(m) }
func (*GasPool) ProtoMessage()    {}
func (*GasPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{16}
}
func (m *GasPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPool.Merge(m, src)
}
func (m *GasPool) XXX_Size() int {
	return m.Size()
}
func (m *GasPool) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPool.DiscardUnknown(m)
}

var xxx_messageInfo_GasPool proto.InternalMessageInfo

func (m *GasPool) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EventGas struct {
	Pools []GasPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
}

func (m *EventGas) Reset()         { *m = EventGas{} }
func (m *EventGas) String() string { return proto.CompactTextString(m) }
func (*EventGas) ProtoMessage()    {}
func (*EventGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{17}
}
func (m *EventGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGas.Merge(m, src)
}
func (m *EventGas) XXX_Size() int {
	return m.Size()
}
func (m *EventGas) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGas.DiscardUnknown(m)
}

var xxx_messageInfo_EventGas proto.InternalMessageInfo

func (m *EventGas) GetPools() []GasPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventReserve struct {
	ReserveContributor ReserveContributor `protobuf:"bytes,1,opt,name=reserve_contributor,json=reserveContributor,proto3" json:"reserve_contributor"`
	InTx               common.Tx          `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventReserve) Reset()         { *m = EventReserve{} }
func (m *EventReserve) String() string { return proto.CompactTextString(m) }
func (*EventReserve) ProtoMessage()    {}
func (*EventReserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{18}
}
func (m *EventReserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReserve.Merge(m, src)
}
func (m *EventReserve) XXX_Size() int {
	return m.Size()
}
func (m *EventReserve) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReserve.DiscardUnknown(m)
}

var xxx_messageInfo_EventReserve proto.InternalMessageInfo

func (m *EventReserve) GetReserveContributor() ReserveContributor {
	if m != nil {
		return m.ReserveContributor
	}
	return ReserveContributor{}
}

func (m *EventReserve) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventScheduledOutbound struct {
	OutTx TxOutItem `protobuf:"bytes,1,opt,name=out_tx,json=outTx,proto3" json:"out_tx"`
}

func (m *EventScheduledOutbound) Reset()         { *m = EventScheduledOutbound{} }
func (m *EventScheduledOutbound) String() string { return proto.CompactTextString(m) }
func (*EventScheduledOutbound) ProtoMessage()    {}
func (*EventScheduledOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{19}
}
func (m *EventScheduledOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventScheduledOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventScheduledOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventScheduledOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventScheduledOutbound.Merge(m, src)
}
func (m *EventScheduledOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventScheduledOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventScheduledOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventScheduledOutbound proto.InternalMessageInfo

func (m *EventScheduledOutbound) GetOutTx() TxOutItem {
	if m != nil {
		return m.OutTx
	}
	return TxOutItem{}
}

type EventSecurity struct {
	Msg string    `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Tx  common.Tx `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventSecurity) Reset()         { *m = EventSecurity{} }
func (m *EventSecurity) String() string { return proto.CompactTextString(m) }
func (*EventSecurity) ProtoMessage()    {}
func (*EventSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{20}
}
func (m *EventSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecurity.Merge(m, src)
}
func (m *EventSecurity) XXX_Size() int {
	return m.Size()
}
func (m *EventSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecurity proto.InternalMessageInfo

func (m *EventSecurity) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *EventSecurity) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventSlash struct {
	Pool        gitlab_com_thorchain_thornode_v3_common.Asset `protobuf:"bytes,1,opt,name=pool,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"pool"`
	SlashAmount []PoolAmt                                     `protobuf:"bytes,2,rep,name=slash_amount,json=slashAmount,proto3" json:"slash_amount"`
}

func (m *EventSlash) Reset()         { *m = EventSlash{} }
func (m *EventSlash) String() string { return proto.CompactTextString(m) }
func (*EventSlash) ProtoMessage()    {}
func (*EventSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{21}
}
func (m *EventSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlash.Merge(m, src)
}
func (m *EventSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlash proto.InternalMessageInfo

func (m *EventSlash) GetSlashAmount() []PoolAmt {
	if m != nil {
		return m.SlashAmount
	}
	return nil
}

type EventErrata struct {
	TxID  gitlab_com_thorchain_thornode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
	Pools PoolMods                                     `protobuf:"bytes,2,rep,name=pools,proto3,castrepeated=PoolMods" json:"pools"`
}

func (m *EventErrata) Reset()         { *m = EventErrata{} }
func (m *EventErrata) String() string { return proto.CompactTextString(m) }
func (*EventErrata) ProtoMessage()    {}
func (*EventErrata) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{22}
}
func (m *EventErrata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventErrata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventErrata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventErrata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventErrata.Merge(m, src)
}
func (m *EventErrata) XXX_Size() int {
	return m.Size()
}
func (m *EventErrata) XXX_DiscardUnknown() {
	xxx_messageInfo_EventErrata.DiscardUnknown(m)
}

var xxx_messageInfo_EventErrata proto.InternalMessageInfo

func (m *EventErrata) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventErrata) GetPools() PoolMods {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventFee struct {
	TxID       gitlab_com_thorchain_thornode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
	Fee        common.Fee                                   `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee"`
	SynthUnits cosmossdk_io_math.Uint                       `protobuf:"bytes,3,opt,name=synth_units,json=synthUnits,proto3,customtype=cosmossdk.io/math.Uint" json:"synth_units"`
}

func (m *EventFee) Reset()         { *m = EventFee{} }
func (m *EventFee) String() string { return proto.CompactTextString(m) }
func (*EventFee) ProtoMessage()    {}
func (*EventFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{23}
}
func (m *EventFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFee.Merge(m, src)
}
func (m *EventFee) XXX_Size() int {
	return m.Size()
}
func (m *EventFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventFee proto.InternalMessageInfo

func (m *EventFee) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventFee) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventOutbound struct {
	InTxID gitlab_com_thorchain_thornode_v3_common.TxID `protobuf:"bytes,1,opt,name=in_tx_id,json=inTxId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"in_tx_id,omitempty"`
	Tx     common.Tx                                    `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventOutbound) Reset()         { *m = EventOutbound{} }
func (m *EventOutbound) String() string { return proto.CompactTextString(m) }
func (*EventOutbound) ProtoMessage()    {}
func (*EventOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{24}
}
func (m *EventOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutbound.Merge(m, src)
}
func (m *EventOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutbound proto.InternalMessageInfo

func (m *EventOutbound) GetInTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.InTxID
	}
	return ""
}

func (m *EventOutbound) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventTssKeygenSuccess struct {
	PubKey  gitlab_com_thorchain_thornode_v3_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.PubKey" json:"pub_key,omitempty"`
	Members []string                                       `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Height  int64                                          `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenSuccess) Reset()         { *m = EventTssKeygenSuccess{} }
func (m *EventTssKeygenSuccess) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenSuccess) ProtoMessage()    {}
func (*EventTssKeygenSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{25}
}
func (m *EventTssKeygenSuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenSuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenSuccess.Merge(m, src)
}
func (m *EventTssKeygenSuccess) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenSuccess proto.InternalMessageInfo

func (m *EventTssKeygenSuccess) GetPubKey() gitlab_com_thorchain_thornode_v3_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenSuccess) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *EventTssKeygenSuccess) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenFailure struct {
	FailReason string   `protobuf:"bytes,1,opt,name=fail_reason,json=failReason,proto3" json:"fail_reason,omitempty"`
	IsUnicast  bool     `protobuf:"varint,2,opt,name=is_unicast,json=isUnicast,proto3" json:"is_unicast,omitempty"`
	BlameNodes []string `protobuf:"bytes,3,rep,name=blame_nodes,json=blameNodes,proto3" json:"blame_nodes,omitempty"`
	Round      string   `protobuf:"bytes,4,opt,name=round,proto3" json:"round,omitempty"`
	Height     int64    `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenFailure) Reset()         { *m = EventTssKeygenFailure{} }
func (m *EventTssKeygenFailure) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenFailure) ProtoMessage()    {}
func (*EventTssKeygenFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{26}
}
func (m *EventTssKeygenFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenFailure.Merge(m, src)
}
func (m *EventTssKeygenFailure) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenFailure.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenFailure proto.InternalMessageInfo

func (m *EventTssKeygenFailure) GetFailReason() string {
	if m != nil {
		return m.FailReason
	}
	return ""
}

func (m *EventTssKeygenFailure) GetIsUnicast() bool {
	if m != nil {
		return m.IsUnicast
	}
	return false
}

func (m *EventTssKeygenFailure) GetBlameNodes() []string {
	if m != nil {
		return m.BlameNodes
	}
	return nil
}

func (m *EventTssKeygenFailure) GetRound() string {
	if m != nil {
		return m.Round
	}
	return ""
}

func (m *EventTssKeygenFailure) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenMetric struct {
	PubKey           gitlab_com_thorchain_thornode_v3_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.PubKey" json:"pub_key,omitempty"`
	MedianDurationMs int64                                          `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeygenMetric) Reset()         { *m = EventTssKeygenMetric{} }
func (m *EventTssKeygenMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenMetric) ProtoMessage()    {}
func (*EventTssKeygenMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{27}
}
func (m *EventTssKeygenMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenMetric.Merge(m, src)
}
func (m *EventTssKeygenMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenMetric proto.InternalMessageInfo

func (m *EventTssKeygenMetric) GetPubKey() gitlab_com_thorchain_thornode_v3_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventTssKeysignMetric struct {
	TxID             gitlab_com_thorchain_thornode_v3_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
	MedianDurationMs int64                                        `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeysignMetric) Reset()         { *m = EventTssKeysignMetric{} }
func (m *EventTssKeysignMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeysignMetric) ProtoMessage()    {}
func (*EventTssKeysignMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{28}
}
func (m *EventTssKeysignMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeysignMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeysignMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeysignMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeysignMetric.Merge(m, src)
}
func (m *EventTssKeysignMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeysignMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeysignMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeysignMetric proto.InternalMessageInfo

func (m *EventTssKeysignMetric) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventTssKeysignMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventSlashPoint struct {
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	SlashPoints int64                                         `protobuf:"varint,2,opt,name=slash_points,json=slashPoints,proto3" json:"slash_points,omitempty"`
	Reason      string                                        `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventSlashPoint) Reset()         { *m = EventSlashPoint{} }
func (m *EventSlashPoint) String() string { return proto.CompactTextString(m) }
func (*EventSlashPoint) ProtoMessage()    {}
func (*EventSlashPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{29}
}
func (m *EventSlashPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlashPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlashPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlashPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlashPoint.Merge(m, src)
}
func (m *EventSlashPoint) XXX_Size() int {
	return m.Size()
}
func (m *EventSlashPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlashPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlashPoint proto.InternalMessageInfo

func (m *EventSlashPoint) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventSlashPoint) GetSlashPoints() int64 {
	if m != nil {
		return m.SlashPoints
	}
	return 0
}

func (m *EventSlashPoint) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventPoolBalanceChanged struct {
	PoolChange PoolMod `protobuf:"bytes,1,opt,name=pool_change,json=poolChange,proto3" json:"pool_change"`
	Reason     string  `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventPoolBalanceChanged) Reset()         { *m = EventPoolBalanceChanged{} }
func (m *EventPoolBalanceChanged) String() string { return proto.CompactTextString(m) }
func (*EventPoolBalanceChanged) ProtoMessage()    {}
func (*EventPoolBalanceChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{30}
}
func (m *EventPoolBalanceChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPoolBalanceChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPoolBalanceChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPoolBalanceChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPoolBalanceChanged.Merge(m, src)
}
func (m *EventPoolBalanceChanged) XXX_Size() int {
	return m.Size()
}
func (m *EventPoolBalanceChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPoolBalanceChanged.DiscardUnknown(m)
}

var xxx_messageInfo_EventPoolBalanceChanged proto.InternalMessageInfo

func (m *EventPoolBalanceChanged) GetPoolChange() PoolMod {
	if m != nil {
		return m.PoolChange
	}
	return PoolMod{}
}

func (m *EventPoolBalanceChanged) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventMintBurn struct {
	Supply MintBurnSupplyType     `protobuf:"varint,1,opt,name=supply,proto3,enum=types.MintBurnSupplyType" json:"supply,omitempty"`
	Denom  string                 `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Amount cosmossdk_io_math.Uint `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Reason string                 `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventMintBurn) Reset()         { *m = EventMintBurn{} }
func (m *EventMintBurn) String() string { return proto.CompactTextString(m) }
func (*EventMintBurn) ProtoMessage()    {}
func (*EventMintBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{31}
}
func (m *EventMintBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMintBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMintBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMintBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMintBurn.Merge(m, src)
}
func (m *EventMintBurn) XXX_Size() int {
	return m.Size()
}
func (m *EventMintBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMintBurn.DiscardUnknown(m)
}

var xxx_messageInfo_EventMintBurn proto.InternalMessageInfo

func (m *EventMintBurn) GetSupply() MintBurnSupplyType {
	if m != nil {
		return m.Supply
	}
	return MintBurnSupplyType_mint
}

func (m *EventMintBurn) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *EventMintBurn) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventTradeAccountDeposit struct {
	Amount       cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset        gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,2,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountDeposit) Reset()         { *m = EventTradeAccountDeposit{} }
func (m *EventTradeAccountDeposit) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountDeposit) ProtoMessage()    {}
func (*EventTradeAccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{32}
}
func (m *EventTradeAccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountDeposit.Merge(m, src)
}
func (m *EventTradeAccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountDeposit proto.InternalMessageInfo

func (m *EventTradeAccountDeposit) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventTradeAccountWithdraw struct {
	Amount       cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset        gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,2,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountWithdraw) Reset()         { *m = EventTradeAccountWithdraw{} }
func (m *EventTradeAccountWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountWithdraw) ProtoMessage()    {}
func (*EventTradeAccountWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{33}
}
func (m *EventTradeAccountWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountWithdraw.Merge(m, src)
}
func (m *EventTradeAccountWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountWithdraw proto.InternalMessageInfo

func (m *EventTradeAccountWithdraw) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSecuredAssetDeposit struct {
	Amount       cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset        common.Asset                                    `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSecuredAssetDeposit) Reset()         { *m = EventSecuredAssetDeposit{} }
func (m *EventSecuredAssetDeposit) String() string { return proto.CompactTextString(m) }
func (*EventSecuredAssetDeposit) ProtoMessage()    {}
func (*EventSecuredAssetDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{34}
}
func (m *EventSecuredAssetDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecuredAssetDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecuredAssetDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecuredAssetDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecuredAssetDeposit.Merge(m, src)
}
func (m *EventSecuredAssetDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventSecuredAssetDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecuredAssetDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecuredAssetDeposit proto.InternalMessageInfo

func (m *EventSecuredAssetDeposit) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSecuredAssetDeposit) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventSecuredAssetDeposit) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventSecuredAssetDeposit) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventSecuredAssetWithdraw struct {
	Amount       cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset        common.Asset                                    `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSecuredAssetWithdraw) Reset()         { *m = EventSecuredAssetWithdraw{} }
func (m *EventSecuredAssetWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventSecuredAssetWithdraw) ProtoMessage()    {}
func (*EventSecuredAssetWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{35}
}
func (m *EventSecuredAssetWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecuredAssetWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecuredAssetWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecuredAssetWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecuredAssetWithdraw.Merge(m, src)
}
func (m *EventSecuredAssetWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventSecuredAssetWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecuredAssetWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecuredAssetWithdraw proto.InternalMessageInfo

func (m *EventSecuredAssetWithdraw) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSecuredAssetWithdraw) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventSecuredAssetWithdraw) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventSecuredAssetWithdraw) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventRUNEPoolDeposit struct {
	RuneAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"rune_address,omitempty"`
	RuneAmount  cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=rune_amount,json=runeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amount"`
	Units       cosmossdk_io_math.Uint                        `protobuf:"bytes,3,opt,name=units,proto3,customtype=cosmossdk.io/math.Uint" json:"units"`
	TxId        gitlab_com_thorchain_thornode_v3_common.TxID  `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventRUNEPoolDeposit) Reset()         { *m = EventRUNEPoolDeposit{} }
func (m *EventRUNEPoolDeposit) String() string { return proto.CompactTextString(m) }
func (*EventRUNEPoolDeposit) ProtoMessage()    {}
func (*EventRUNEPoolDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{36}
}
func (m *EventRUNEPoolDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRUNEPoolDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRUNEPoolDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRUNEPoolDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRUNEPoolDeposit.Merge(m, src)
}
func (m *EventRUNEPoolDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventRUNEPoolDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRUNEPoolDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventRUNEPoolDeposit proto.InternalMessageInfo

func (m *EventRUNEPoolDeposit) GetRuneAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.RuneAddress
	}
	return nil
}

func (m *EventRUNEPoolDeposit) GetTxId() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

type EventRUNEPoolWithdraw struct {
	RuneAddress       github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"rune_address,omitempty"`
	BasisPoints       int64                                           `protobuf:"varint,2,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	RuneAmount        cosmossdk_io_math.Uint                          `protobuf:"bytes,3,opt,name=rune_amount,json=runeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amount"`
	Units             cosmossdk_io_math.Uint                          `protobuf:"bytes,4,opt,name=units,proto3,customtype=cosmossdk.io/math.Uint" json:"units"`
	TxId              gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
	AffiliateBasisPts int64                                           `protobuf:"varint,6,opt,name=affiliate_basis_pts,json=affiliateBasisPts,proto3" json:"affiliate_basis_pts,omitempty"`
	AffiliateAmount   cosmossdk_io_math.Uint                          `protobuf:"bytes,7,opt,name=affiliate_amount,json=affiliateAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"affiliate_amount"`
	AffiliateAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,8,opt,name=affiliate_address,json=affiliateAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"affiliate_address,omitempty"`
}

func (m *EventRUNEPoolWithdraw) Reset()         { *m = EventRUNEPoolWithdraw{} }
func (m *EventRUNEPoolWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventRUNEPoolWithdraw) ProtoMessage()    {}
func (*EventRUNEPoolWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{37}
}
func (m *EventRUNEPoolWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRUNEPoolWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRUNEPoolWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRUNEPoolWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRUNEPoolWithdraw.Merge(m, src)
}
func (m *EventRUNEPoolWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventRUNEPoolWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRUNEPoolWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventRUNEPoolWithdraw proto.InternalMessageInfo

func (m *EventRUNEPoolWithdraw) GetRuneAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.RuneAddress
	}
	return nil
}

func (m *EventRUNEPoolWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventRUNEPoolWithdraw) GetTxId() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *EventRUNEPoolWithdraw) GetAffiliateBasisPts() int64 {
	if m != nil {
		return m.AffiliateBasisPts
	}
	return 0
}

func (m *EventRUNEPoolWithdraw) GetAffiliateAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AffiliateAddress
	}
	return ""
}

type EventLoanOpen struct {
	CollateralDeposited    cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=collateral_deposited,json=collateralDeposited,proto3,customtype=cosmossdk.io/math.Uint" json:"collateral_deposited"`
	CollateralAsset        gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"collateral_asset"`
	CollateralizationRatio cosmossdk_io_math.Uint                          `protobuf:"bytes,3,opt,name=collateralization_ratio,json=collateralizationRatio,proto3,customtype=cosmossdk.io/math.Uint" json:"collateralization_ratio"`
	DebtIssued             cosmossdk_io_math.Uint                          `protobuf:"bytes,4,opt,name=debt_issued,json=debtIssued,proto3,customtype=cosmossdk.io/math.Uint" json:"debt_issued"`
	Owner                  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,5,opt,name=owner,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"owner,omitempty"`
	TargetAsset            gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,6,opt,name=target_asset,json=targetAsset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"target_asset"`
	TxID                   gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLoanOpen) Reset()         { *m = EventLoanOpen{} }
func (m *EventLoanOpen) String() string { return proto.CompactTextString(m) }
func (*EventLoanOpen) ProtoMessage()    {}
func (*EventLoanOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{38}
}
func (m *EventLoanOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLoanOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLoanOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLoanOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLoanOpen.Merge(m, src)
}
func (m *EventLoanOpen) XXX_Size() int {
	return m.Size()
}
func (m *EventLoanOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLoanOpen.DiscardUnknown(m)
}

var xxx_messageInfo_EventLoanOpen proto.InternalMessageInfo

func (m *EventLoanOpen) GetOwner() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventLoanOpen) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventLoanRepayment struct {
	CollateralWithdrawn cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=collateral_withdrawn,json=collateralWithdrawn,proto3,customtype=cosmossdk.io/math.Uint" json:"collateral_withdrawn"`
	CollateralAsset     gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"collateral_asset"`
	DebtRepaid          cosmossdk_io_math.Uint                          `protobuf:"bytes,3,opt,name=debt_repaid,json=debtRepaid,proto3,customtype=cosmossdk.io/math.Uint" json:"debt_repaid"`
	Owner               gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=owner,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"owner,omitempty"`
	TxID                gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLoanRepayment) Reset()         { *m = EventLoanRepayment{} }
func (m *EventLoanRepayment) String() string { return proto.CompactTextString(m) }
func (*EventLoanRepayment) ProtoMessage()    {}
func (*EventLoanRepayment) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{39}
}
func (m *EventLoanRepayment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLoanRepayment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLoanRepayment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLoanRepayment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLoanRepayment.Merge(m, src)
}
func (m *EventLoanRepayment) XXX_Size() int {
	return m.Size()
}
func (m *EventLoanRepayment) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLoanRepayment.DiscardUnknown(m)
}

var xxx_messageInfo_EventLoanRepayment proto.InternalMessageInfo

func (m *EventLoanRepayment) GetOwner() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventLoanRepayment) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventTHORName struct {
	Name            string                                          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain           gitlab_com_thorchain_thornode_v3_common.Chain   `protobuf:"bytes,2,opt,name=chain,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Chain" json:"chain,omitempty"`
	Address         gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=address,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"address,omitempty"`
	RegistrationFee cosmossdk_io_math.Uint                          `protobuf:"bytes,4,opt,name=registration_fee,json=registrationFee,proto3,customtype=cosmossdk.io/math.Uint" json:"registration_fee"`
	FundAmt         cosmossdk_io_math.Uint                          `protobuf:"bytes,5,opt,name=fund_amt,json=fundAmt,proto3,customtype=cosmossdk.io/math.Uint" json:"fund_amt"`
	Expire          int64                                           `protobuf:"varint,6,opt,name=expire,proto3" json:"expire,omitempty"`
	Owner           github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,7,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
}

func (m *EventTHORName) Reset()         { *m = EventTHORName{} }
func (m *EventTHORName) String() string { return proto.CompactTextString(m) }
func (*EventTHORName) ProtoMessage()    {}
func (*EventTHORName) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{40}
}
func (m *EventTHORName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTHORName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTHORName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTHORName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTHORName.Merge(m, src)
}
func (m *EventTHORName) XXX_Size() int {
	return m.Size()
}
func (m *EventTHORName) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTHORName.DiscardUnknown(m)
}

var xxx_messageInfo_EventTHORName proto.InternalMessageInfo

func (m *EventTHORName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventTHORName) GetChain() gitlab_com_thorchain_thornode_v3_common.Chain {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *EventTHORName) GetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventTHORName) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *EventTHORName) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

type EventSetMimir struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EventSetMimir) Reset()         { *m = EventSetMimir{} }
func (m *EventSetMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetMimir) ProtoMessage()    {}
func (*EventSetMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{41}
}
func (m *EventSetMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetMimir.Merge(m, src)
}
func (m *EventSetMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetMimir proto.InternalMessageInfo

func (m *EventSetMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type EventSetNodeMimir struct {
	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value   string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EventSetNodeMimir) Reset()         { *m = EventSetNodeMimir{} }
func (m *EventSetNodeMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetNodeMimir) ProtoMessage()    {}
func (*EventSetNodeMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{42}
}
func (m *EventSetNodeMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetNodeMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetNodeMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetNodeMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetNodeMimir.Merge(m, src)
}
func (m *EventSetNodeMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetNodeMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetNodeMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetNodeMimir proto.InternalMessageInfo

func (m *EventSetNodeMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetNodeMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *EventSetNodeMimir) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventVersion struct {
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *EventVersion) Reset()         { *m = EventVersion{} }
func (m *EventVersion) String() string { return proto.CompactTextString(m) }
func (*EventVersion) ProtoMessage()    {}
func (*EventVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{43}
}
func (m *EventVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVersion.Merge(m, src)
}
func (m *EventVersion) XXX_Size() int {
	return m.Size()
}
func (m *EventVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVersion.DiscardUnknown(m)
}

var xxx_messageInfo_EventVersion proto.InternalMessageInfo

func (m *EventVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type EventSwitch struct {
	Amount       cosmossdk_io_math.Uint                          `protobuf:"bytes,1,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
	Asset        common.Asset                                    `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_v3_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSwitch) Reset()         { *m = EventSwitch{} }
func (m *EventSwitch) String() string { return proto.CompactTextString(m) }
func (*EventSwitch) ProtoMessage()    {}
func (*EventSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{44}
}
func (m *EventSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitch.Merge(m, src)
}
func (m *EventSwitch) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitch proto.InternalMessageInfo

func (m *EventSwitch) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventSwitch) GetAssetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventSwitch) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventSwitch) GetTxID() gitlab_com_thorchain_thornode_v3_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventOperatorRotate struct {
	Signer          github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=signer,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"signer,omitempty"`
	NodeAddress     github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	OperatorAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=operator_address,json=operatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"operator_address,omitempty"`
}

func (m *EventOperatorRotate) Reset()         { *m = EventOperatorRotate{} }
func (m *EventOperatorRotate) String() string { return proto.CompactTextString(m) }
func (*EventOperatorRotate) ProtoMessage()    {}
func (*EventOperatorRotate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{45}
}
func (m *EventOperatorRotate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOperatorRotate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOperatorRotate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOperatorRotate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOperatorRotate.Merge(m, src)
}
func (m *EventOperatorRotate) XXX_Size() int {
	return m.Size()
}
func (m *EventOperatorRotate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOperatorRotate.DiscardUnknown(m)
}

var xxx_messageInfo_EventOperatorRotate proto.InternalMessageInfo

func (m *EventOperatorRotate) GetSigner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Signer
	}
	return nil
}

func (m *EventOperatorRotate) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventOperatorRotate) GetOperatorAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.OperatorAddress
	}
	return nil
}

type EventTCYDistribution struct {
	RuneAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"rune_address,omitempty"`
	RuneAmount  cosmossdk_io_math.Uint                        `protobuf:"bytes,2,opt,name=rune_amount,json=runeAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"rune_amount"`
}

func (m *EventTCYDistribution) Reset()         { *m = EventTCYDistribution{} }
func (m *EventTCYDistribution) String() string { return proto.CompactTextString(m) }
func (*EventTCYDistribution) ProtoMessage()    {}
func (*EventTCYDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{46}
}
func (m *EventTCYDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTCYDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTCYDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTCYDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTCYDistribution.Merge(m, src)
}
func (m *EventTCYDistribution) XXX_Size() int {
	return m.Size()
}
func (m *EventTCYDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTCYDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_EventTCYDistribution proto.InternalMessageInfo

func (m *EventTCYDistribution) GetRuneAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.RuneAddress
	}
	return nil
}

type EventTCYClaim struct {
	RuneAddress gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"rune_address,omitempty"`
	TcyAmount   cosmossdk_io_math.Uint                          `protobuf:"bytes,2,opt,name=tcy_amount,json=tcyAmount,proto3,customtype=cosmossdk.io/math.Uint" json:"tcy_amount"`
	L1Address   gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,3,opt,name=l1_address,json=l1Address,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"l1_address,omitempty"`
	Asset       gitlab_com_thorchain_thornode_v3_common.Asset   `protobuf:"bytes,4,opt,name=asset,proto3,customtype=gitlab.com/thorchain/thornode/v3/common.Asset" json:"asset"`
}

func (m *EventTCYClaim) Reset()         { *m = EventTCYClaim{} }
func (m *EventTCYClaim) String() string { return proto.CompactTextString(m) }
func (*EventTCYClaim) ProtoMessage()    {}
func (*EventTCYClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{47}
}
func (m *EventTCYClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTCYClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTCYClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTCYClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTCYClaim.Merge(m, src)
}
func (m *EventTCYClaim) XXX_Size() int {
	return m.Size()
}
func (m *EventTCYClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTCYClaim.DiscardUnknown(m)
}

var xxx_messageInfo_EventTCYClaim proto.InternalMessageInfo

func (m *EventTCYClaim) GetRuneAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventTCYClaim) GetL1Address() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.L1Address
	}
	return ""
}

type EventTCYStake struct {
	Address gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"address,omitempty"`
	Amount  cosmossdk_io_math.Uint                          `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
}

func (m *EventTCYStake) Reset()         { *m = EventTCYStake{} }
func (m *EventTCYStake) String() string { return proto.CompactTextString(m) }
func (*EventTCYStake) ProtoMessage()    {}
func (*EventTCYStake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{48}
}
func (m *EventTCYStake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTCYStake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTCYStake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTCYStake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTCYStake.Merge(m, src)
}
func (m *EventTCYStake) XXX_Size() int {
	return m.Size()
}
func (m *EventTCYStake) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTCYStake.DiscardUnknown(m)
}

var xxx_messageInfo_EventTCYStake proto.InternalMessageInfo

func (m *EventTCYStake) GetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventTCYUnstake struct {
	Address gitlab_com_thorchain_thornode_v3_common.Address `protobuf:"bytes,1,opt,name=address,proto3,casttype=gitlab.com/thorchain/thornode/v3/common.Address" json:"address,omitempty"`
	Amount  cosmossdk_io_math.Uint                          `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Uint" json:"amount"`
}

func (m *EventTCYUnstake) Reset()         { *m = EventTCYUnstake{} }
func (m *EventTCYUnstake) String() string { return proto.CompactTextString(m) }
func (*EventTCYUnstake) ProtoMessage()    {}
func (*EventTCYUnstake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a149b429e0dcd819, []int{49}
}
func (m *EventTCYUnstake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTCYUnstake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTCYUnstake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTCYUnstake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTCYUnstake.Merge(m, src)
}
func (m *EventTCYUnstake) XXX_Size() int {
	return m.Size()
}
func (m *EventTCYUnstake) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTCYUnstake.DiscardUnknown(m)
}

var xxx_messageInfo_EventTCYUnstake proto.InternalMessageInfo

func (m *EventTCYUnstake) GetAddress() gitlab_com_thorchain_thornode_v3_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("types.PendingLiquidityType", PendingLiquidityType_name, PendingLiquidityType_value)
	proto.RegisterEnum("types.BondType", BondType_name, BondType_value)
	proto.RegisterEnum("types.MintBurnSupplyType", MintBurnSupplyType_name, MintBurnSupplyType_value)
	proto.RegisterType((*PoolMod)(nil), "types.PoolMod")
	proto.RegisterType((*EventLimitSwap)(nil), "types.EventLimitSwap")
	proto.RegisterType((*EventModifyLimitSwap)(nil), "types.EventModifyLimitSwap")
	proto.RegisterType((*EventStreamingSwap)(nil), "types.EventStreamingSwap")
	proto.RegisterType((*EventSwap)(nil), "types.EventSwap")
	proto.RegisterType((*EventAffiliateFee)(nil), "types.EventAffiliateFee")
	proto.RegisterType((*EventAddLiquidity)(nil), "types.EventAddLiquidity")
	proto.RegisterType((*EventWithdraw)(nil), "types.EventWithdraw")
	proto.RegisterType((*EventPendingLiquidity)(nil), "types.EventPendingLiquidity")
	proto.RegisterType((*EventDonate)(nil), "types.EventDonate")
	proto.RegisterType((*EventPool)(nil), "types.EventPool")
	proto.RegisterType((*PoolAmt)(nil), "types.PoolAmt")
	proto.RegisterType((*EventRewards)(nil), "types.EventRewards")
	proto.RegisterType((*EventRefund)(nil), "types.EventRefund")
	proto.RegisterType((*EventBond)(nil), "types.EventBond")
	proto.RegisterType((*EventReBond)(nil), "types.EventReBond")
	proto.RegisterType((*GasPool)(nil), "types.GasPool")
	proto.RegisterType((*EventGas)(nil), "types.EventGas")
	proto.RegisterType((*EventReserve)(nil), "types.EventReserve")
	proto.RegisterType((*EventScheduledOutbound)(nil), "types.EventScheduledOutbound")
	proto.RegisterType((*EventSecurity)(nil), "types.EventSecurity")
	proto.RegisterType((*EventSlash)(nil), "types.EventSlash")
	proto.RegisterType((*EventErrata)(nil), "types.EventErrata")
	proto.RegisterType((*EventFee)(nil), "types.EventFee")
	proto.RegisterType((*EventOutbound)(nil), "types.EventOutbound")
	proto.RegisterType((*EventTssKeygenSuccess)(nil), "types.EventTssKeygenSuccess")
	proto.RegisterType((*EventTssKeygenFailure)(nil), "types.EventTssKeygenFailure")
	proto.RegisterType((*EventTssKeygenMetric)(nil), "types.EventTssKeygenMetric")
	proto.RegisterType((*EventTssKeysignMetric)(nil), "types.EventTssKeysignMetric")
	proto.RegisterType((*EventSlashPoint)(nil), "types.EventSlashPoint")
	proto.RegisterType((*EventPoolBalanceChanged)(nil), "types.EventPoolBalanceChanged")
	proto.RegisterType((*EventMintBurn)(nil), "types.EventMintBurn")
	proto.RegisterType((*EventTradeAccountDeposit)(nil), "types.EventTradeAccountDeposit")
	proto.RegisterType((*EventTradeAccountWithdraw)(nil), "types.EventTradeAccountWithdraw")
	proto.RegisterType((*EventSecuredAssetDeposit)(nil), "types.EventSecuredAssetDeposit")
	proto.RegisterType((*EventSecuredAssetWithdraw)(nil), "types.EventSecuredAssetWithdraw")
	proto.RegisterType((*EventRUNEPoolDeposit)(nil), "types.EventRUNEPoolDeposit")
	proto.RegisterType((*EventRUNEPoolWithdraw)(nil), "types.EventRUNEPoolWithdraw")
	proto.RegisterType((*EventLoanOpen)(nil), "types.EventLoanOpen")
	proto.RegisterType((*EventLoanRepayment)(nil), "types.EventLoanRepayment")
	proto.RegisterType((*EventTHORName)(nil), "types.EventTHORName")
	proto.RegisterType((*EventSetMimir)(nil), "types.EventSetMimir")
	proto.RegisterType((*EventSetNodeMimir)(nil), "types.EventSetNodeMimir")
	proto.RegisterType((*EventVersion)(nil), "types.EventVersion")
	proto.RegisterType((*EventSwitch)(nil), "types.EventSwitch")
	proto.RegisterType((*EventOperatorRotate)(nil), "types.EventOperatorRotate")
	proto.RegisterType((*EventTCYDistribution)(nil), "types.EventTCYDistribution")
	proto.RegisterType((*EventTCYClaim)(nil), "types.EventTCYClaim")
	proto.RegisterType((*EventTCYStake)(nil), "types.EventTCYStake")
	proto.RegisterType((*EventTCYUnstake)(nil), "types.EventTCYUnstake")
}

func init() { proto.RegisterFile("types/type_events.proto", fileDescriptor_a149b429e0dcd819) }

var fileDescriptor_a149b429e0dcd819 = []byte{
	// 3104 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0x5d, 0x6c, 0x1c, 0x57,
	0xf5, 0xcf, 0xee, 0xec, 0xe7, 0xd9, 0xb5, 0xbd, 0xb9, 0x71, 0x92, 0x6d, 0xab, 0x7f, 0x9c, 0x4e,
	0xfb, 0x97, 0xdc, 0x28, 0xb1, 0x9b, 0x94, 0xa6, 0x94, 0x10, 0x2a, 0xaf, 0xf3, 0x51, 0xab, 0x71,
	0x92, 0x8e, 0x37, 0xfd, 0x02, 0x34, 0xcc, 0xce, 0x5c, 0xaf, 0xaf, 0xb2, 0x33, 0xb3, 0x9d, 0x7b,
	0xc7, 0xf6, 0x22, 0xf1, 0x88, 0x78, 0x02, 0x15, 0xa9, 0x54, 0xbc, 0x21, 0x55, 0x02, 0xa1, 0x22,
	0x04, 0x12, 0x0f, 0x88, 0x27, 0x5e, 0x78, 0xe8, 0x63, 0x9f, 0x10, 0x02, 0xc9, 0x14, 0xf7, 0x85,
	0x47, 0x10, 0x6f, 0x11, 0x02, 0x74, 0xbf, 0x66, 0xd7, 0xde, 0xda, 0x19, 0xaf, 0xd7, 0x55, 0x1e,
	0xf2, 0xe2, 0x9d, 0xfb, 0x71, 0xce, 0x9c, 0x39, 0xe7, 0x77, 0xce, 0x3d, 0xf7, 0xdc, 0x6b, 0x38,
	0xcd, 0x7a, 0x5d, 0x4c, 0xe7, 0xf9, 0x5f, 0x1b, 0xaf, 0xe3, 0x80, 0xd1, 0xb9, 0x6e, 0x14, 0xb2,
	0x10, 0xe5, 0xc5, 0xc0, 0x93, 0x27, 0xdc, 0xd0, 0xf7, 0xc3, 0x60, 0x5e, 0xfe, 0xc8, 0xb1, 0x27,
	0x4f, 0x0e, 0x10, 0x75, 0xc3, 0xb0, 0xa3, 0xba, 0x9f, 0x1d, 0xe8, 0x8e, 0x30, 0xc5, 0xd1, 0x3a,
	0xb6, 0xdd, 0x30, 0x60, 0x11, 0x69, 0xc5, 0x2c, 0x8c, 0xd4, 0xac, 0xc1, 0x37, 0xb2, 0x4d, 0x3b,
	0x8c, 0x99, 0x1a, 0x98, 0x6e, 0x87, 0xed, 0x50, 0x3c, 0xce, 0xf3, 0x27, 0xd9, 0x6b, 0xfe, 0x28,
	0x0b, 0xc5, 0xbb, 0x61, 0xd8, 0x59, 0x0e, 0x3d, 0xf4, 0x0e, 0xe4, 0x1d, 0x4a, 0x31, 0xab, 0x67,
	0xce, 0x66, 0x66, 0x2b, 0x97, 0x26, 0xe6, 0x94, 0x54, 0x0b, 0xbc, 0xb3, 0xf1, 0xe2, 0xc7, 0x5b,
	0x33, 0xc7, 0xfe, 0xbc, 0x35, 0x73, 0xa1, 0x4d, 0x58, 0xc7, 0x69, 0xf1, 0xc1, 0x79, 0xb6, 0x16,
	0x46, 0xee, 0x9a, 0x43, 0x02, 0xf1, 0x14, 0x84, 0x1e, 0x9e, 0x5f, 0x7f, 0x61, 0x7e, 0x90, 0xcc,
	0x92, 0x2c, 0xd1, 0xcb, 0x50, 0x8a, 0xe2, 0x00, 0xdb, 0x8e, 0xcf, 0xea, 0xd9, 0xb3, 0x99, 0xd9,
	0x72, 0xe3, 0x8c, 0xe2, 0x77, 0xca, 0x0d, 0xa9, 0x1f, 0x52, 0xea, 0xdd, 0x9f, 0x23, 0xe1, 0xbc,
	0xef, 0xb0, 0xb5, 0xb9, 0x7b, 0x24, 0x60, 0x56, 0x91, 0xcf, 0x5f, 0xf0, 0x19, 0x7a, 0x42, 0x93,
	0x7a, 0x5e, 0xdd, 0x38, 0x9b, 0x99, 0x2d, 0xa9, 0x21, 0xcf, 0x43, 0x57, 0xa0, 0x2c, 0xd8, 0x0b,
	0xb6, 0xb9, 0x54, 0x6c, 0x4b, 0x82, 0x80, 0xf3, 0x7d, 0x2a, 0x21, 0xf6, 0xbc, 0x7a, 0x5e, 0x30,
	0x56, 0x83, 0x9e, 0x67, 0xfe, 0x36, 0x03, 0x93, 0xd7, 0xb9, 0xc1, 0x6e, 0x11, 0x9f, 0xb0, 0x95,
	0x0d, 0xa7, 0x8b, 0xce, 0x41, 0x81, 0x86, 0x71, 0xe4, 0x62, 0xa5, 0x9f, 0xaa, 0xd6, 0xcf, 0x62,
	0x48, 0x82, 0x46, 0x8e, 0xbf, 0xd7, 0x52, 0x33, 0xf8, 0x5c, 0xe6, 0x44, 0x6d, 0x2c, 0x3f, 0x76,
	0x8f, 0xb9, 0x72, 0x06, 0x5a, 0x86, 0x3c, 0xdb, 0xb4, 0x89, 0xfc, 0xb8, 0x72, 0xe3, 0xcb, 0xdb,
	0x5b, 0x33, 0xb9, 0xe6, 0xe6, 0xd2, 0xb5, 0x07, 0x5b, 0x33, 0xe7, 0xd3, 0xea, 0x9a, 0xcf, 0xb7,
	0x72, 0x6c, 0x73, 0xc9, 0x33, 0xbf, 0x9f, 0x85, 0x69, 0x21, 0xf9, 0x72, 0xe8, 0x91, 0xd5, 0x5e,
	0x5f, 0xfe, 0x9b, 0x90, 0x5b, 0x8d, 0x42, 0x5f, 0x48, 0x5f, 0x6e, 0xbc, 0xf0, 0x60, 0x6b, 0x66,
	0x3e, 0xb5, 0x29, 0x3d, 0x2f, 0xc2, 0x94, 0x5a, 0x82, 0xc1, 0x80, 0x22, 0xb2, 0x07, 0x50, 0x84,
	0xf1, 0x50, 0x45, 0x34, 0xe1, 0x94, 0xcf, 0x65, 0x26, 0xd8, 0xb3, 0x65, 0x97, 0xed, 0xf8, 0x61,
	0x1c, 0xa4, 0x35, 0xed, 0xb4, 0xa6, 0x6e, 0x0a, 0xe2, 0x05, 0x41, 0x6b, 0x7e, 0x6a, 0x00, 0x12,
	0xfa, 0x58, 0x61, 0x11, 0x76, 0x7c, 0x12, 0xb4, 0x85, 0x36, 0x12, 0xad, 0x67, 0xc6, 0xa1, 0x75,
	0xf4, 0x24, 0x94, 0x48, 0xc0, 0x70, 0xb4, 0xee, 0x74, 0x84, 0x56, 0x72, 0x56, 0xd2, 0xe6, 0x63,
	0xef, 0xc6, 0x4e, 0xc0, 0x08, 0xeb, 0x09, 0x2d, 0xe4, 0xac, 0xa4, 0x8d, 0xa6, 0x21, 0xef, 0x26,
	0x9f, 0x98, 0xb3, 0x64, 0x03, 0xcd, 0x40, 0xa5, 0xe3, 0x50, 0x66, 0xaf, 0x61, 0xd2, 0x5e, 0x63,
	0x02, 0x9c, 0x86, 0x05, 0xbc, 0xeb, 0x55, 0xd1, 0x83, 0x16, 0xa0, 0xca, 0x22, 0xc7, 0xc3, 0x4a,
	0x4f, 0xf5, 0x42, 0x2a, 0x05, 0x55, 0x04, 0x8d, 0xd4, 0x0e, 0x3a, 0x0f, 0x45, 0x0f, 0x77, 0x43,
	0x4a, 0x58, 0xbd, 0xb8, 0xa7, 0x69, 0xf4, 0x14, 0x64, 0x42, 0x96, 0x04, 0xf5, 0xd2, 0x9e, 0x13,
	0xb3, 0x24, 0x40, 0xcf, 0x82, 0x11, 0xc6, 0xac, 0x5e, 0xde, 0x73, 0x12, 0x1f, 0x46, 0x4f, 0x43,
	0x75, 0xd5, 0x21, 0x1d, 0xec, 0xd9, 0x74, 0xc3, 0xe9, 0xd2, 0x3a, 0x9c, 0x35, 0x66, 0x73, 0x56,
	0x45, 0xf6, 0x71, 0xd3, 0x50, 0x34, 0x07, 0x27, 0x06, 0xa6, 0xd8, 0x11, 0x76, 0x68, 0x18, 0xd0,
	0x7a, 0xe5, 0xac, 0x31, 0x5b, 0xb6, 0x8e, 0xf7, 0x67, 0x5a, 0x72, 0xc0, 0xfc, 0x7b, 0x1e, 0xca,
	0xd2, 0xc4, 0xdc, 0xb2, 0x6f, 0x41, 0x8e, 0x47, 0xcd, 0xb1, 0x46, 0x31, 0xc1, 0x11, 0xbd, 0x02,
	0x15, 0x21, 0xd0, 0x80, 0x6b, 0x3f, 0x5c, 0xe9, 0xc0, 0x49, 0x94, 0xce, 0xaf, 0x40, 0x59, 0x30,
	0xa0, 0x1d, 0xd2, 0x55, 0xee, 0xfe, 0xd0, 0x78, 0xc5, 0x09, 0x56, 0x3a, 0xa4, 0x8b, 0x16, 0x61,
	0xa2, 0x43, 0xde, 0x8d, 0x89, 0x47, 0x58, 0xcf, 0x5e, 0xc5, 0x38, 0xa5, 0x57, 0x54, 0x13, 0xa2,
	0x1b, 0x18, 0xa3, 0xd7, 0xe1, 0xe4, 0x0e, 0x26, 0x36, 0x09, 0x6c, 0x1e, 0x4d, 0x05, 0xc6, 0x1e,
	0xce, 0x0c, 0x0d, 0x32, 0x5b, 0x0a, 0xac, 0x38, 0xc0, 0xe8, 0xff, 0x21, 0x4f, 0x02, 0x9b, 0x6d,
	0x0a, 0x10, 0x56, 0x2e, 0xc1, 0x5c, 0xe2, 0x1d, 0xca, 0xec, 0x39, 0x12, 0x34, 0x37, 0xd1, 0x73,
	0x50, 0x0c, 0x63, 0x66, 0xb3, 0x4d, 0xaa, 0xf0, 0x36, 0x3c, 0xb1, 0x10, 0xc6, 0xac, 0xb9, 0x49,
	0xd1, 0x45, 0x00, 0xec, 0x13, 0x66, 0xcb, 0xd5, 0x68, 0x6f, 0xd0, 0x95, 0xf9, 0x2c, 0x61, 0x20,
	0x61, 0x9a, 0x5e, 0xc0, 0xd6, 0xec, 0x38, 0x20, 0x8c, 0x0a, 0x0c, 0xa6, 0x31, 0x0d, 0x27, 0xb9,
	0xc7, 0x29, 0xd0, 0x65, 0x38, 0x4d, 0x75, 0x80, 0x90, 0xb0, 0x4b, 0x7c, 0x16, 0x84, 0x6b, 0x9e,
	0xa4, 0x83, 0xf1, 0xe3, 0x75, 0xed, 0xc0, 0xcf, 0xc3, 0xf4, 0x2e, 0x3a, 0xe9, 0xcf, 0x15, 0x41,
	0x84, 0x76, 0x10, 0x2d, 0x0a, 0xe7, 0xbe, 0x02, 0x65, 0x8e, 0x26, 0x09, 0x82, 0x6a, 0x3a, 0x10,
	0x70, 0x02, 0x0e, 0x02, 0xf3, 0x6f, 0x06, 0x1c, 0x17, 0x50, 0x5f, 0x58, 0x5d, 0x25, 0x1d, 0xe2,
	0x30, 0xcc, 0xad, 0x3a, 0xe6, 0x60, 0x86, 0x20, 0xe7, 0x63, 0x3f, 0x94, 0x00, 0xb7, 0xc4, 0x33,
	0x0f, 0x62, 0x82, 0xc8, 0xf1, 0xb1, 0x44, 0xae, 0x95, 0xb4, 0xd1, 0x1b, 0x50, 0xd5, 0x2b, 0x34,
	0x5f, 0x26, 0x14, 0x30, 0x47, 0x5a, 0x61, 0x2a, 0x6a, 0x69, 0xe7, 0x8d, 0x7e, 0x42, 0x92, 0x1f,
	0x7f, 0x42, 0xb2, 0x00, 0xd5, 0x76, 0x14, 0x52, 0xaa, 0x97, 0x98, 0x94, 0x11, 0x54, 0xd0, 0xc8,
	0x95, 0x05, 0x9d, 0x86, 0x22, 0xf7, 0xa0, 0x56, 0x57, 0x22, 0x3a, 0x67, 0x15, 0x56, 0x31, 0x6e,
	0x74, 0x29, 0xba, 0x0a, 0xc0, 0x07, 0x14, 0xe7, 0x52, 0x2a, 0xce, 0xe5, 0x55, 0x8c, 0xd5, 0x8a,
	0xf5, 0xd3, 0xbc, 0xb6, 0xb1, 0xe7, 0xdd, 0xd2, 0xfe, 0x76, 0x84, 0x61, 0xed, 0x3a, 0x4c, 0x76,
	0xa3, 0x70, 0x9d, 0x78, 0x38, 0x52, 0xee, 0x93, 0x2e, 0xb2, 0x4d, 0x68, 0x2a, 0xe9, 0x41, 0xbb,
	0x51, 0x60, 0x8c, 0x09, 0x05, 0xaf, 0x40, 0x45, 0xa5, 0x8e, 0x07, 0xc8, 0x05, 0x40, 0x66, 0x8f,
	0xc2, 0x4e, 0x0b, 0x50, 0xd5, 0x59, 0xa2, 0xe0, 0x90, 0x2e, 0xd4, 0x55, 0x54, 0xa2, 0x28, 0x58,
	0xbc, 0x03, 0x82, 0xa1, 0x2d, 0xbd, 0x4c, 0x62, 0xe5, 0xab, 0xdb, 0x5b, 0x33, 0x25, 0x1e, 0x01,
	0x47, 0xf2, 0x34, 0x91, 0xd3, 0x36, 0xb9, 0xb7, 0x7d, 0x13, 0xe4, 0xab, 0x14, 0xf3, 0xa2, 0x60,
	0x7e, 0x75, 0x7b, 0x6b, 0xa6, 0x2c, 0x8c, 0x34, 0x12, 0x77, 0x99, 0xd9, 0x0a, 0xf6, 0x6f, 0xc1,
	0x44, 0x92, 0xe6, 0x0a, 0xbb, 0x94, 0x46, 0xb7, 0x4b, 0x55, 0xe7, 0xc7, 0xbc, 0x65, 0xfe, 0xce,
	0x80, 0x09, 0x81, 0xd3, 0x37, 0x09, 0x5b, 0xf3, 0x22, 0x67, 0xe3, 0xd1, 0xc7, 0xe8, 0xd3, 0x50,
	0x6d, 0x39, 0x94, 0x50, 0xbb, 0x1b, 0x92, 0x80, 0x49, 0x8c, 0x1a, 0x56, 0x45, 0xf4, 0xdd, 0x15,
	0x5d, 0x68, 0x81, 0x6f, 0x0b, 0x7a, 0xbe, 0x8f, 0x59, 0xd4, 0x13, 0x60, 0xab, 0x36, 0x9e, 0x51,
	0x2f, 0x79, 0x6a, 0xf8, 0x25, 0xb7, 0x70, 0xdb, 0x71, 0x7b, 0xd7, 0xb0, 0x6b, 0xf5, 0xa9, 0xfa,
	0x2b, 0x62, 0x7e, 0xdf, 0x15, 0xf1, 0xea, 0x8e, 0x65, 0x2e, 0x5d, 0x00, 0x1a, 0x58, 0xf2, 0xae,
	0x80, 0x68, 0xc8, 0xe5, 0xbb, 0x98, 0x6e, 0x1d, 0xe1, 0x04, 0x1c, 0xb2, 0xe6, 0x87, 0x79, 0x38,
	0x29, 0x6c, 0x77, 0x17, 0x07, 0x1e, 0x09, 0xda, 0x5f, 0x44, 0x9c, 0xf9, 0x1a, 0x54, 0xbb, 0xf2,
	0x6d, 0x36, 0xdf, 0x9e, 0x0a, 0x0b, 0x4e, 0x5e, 0x7a, 0x6a, 0x4e, 0xec, 0x58, 0xe7, 0x76, 0x0b,
	0xd2, 0xec, 0x75, 0xb1, 0x55, 0x51, 0x04, 0xbc, 0xf1, 0xe8, 0x06, 0x98, 0x21, 0x17, 0xcb, 0x8f,
	0xc9, 0xc5, 0x86, 0x42, 0x57, 0xe1, 0xb0, 0xa1, 0xab, 0x78, 0x94, 0xa1, 0xab, 0x34, 0xde, 0xd0,
	0x65, 0xfe, 0x20, 0x03, 0x15, 0x01, 0xd2, 0x6b, 0x61, 0xe0, 0x30, 0x7c, 0x84, 0xd0, 0x4c, 0x3c,
	0x36, 0xbb, 0x9f, 0xc7, 0x9a, 0xef, 0x65, 0xd4, 0x46, 0xe3, 0x2e, 0x27, 0x3a, 0x3a, 0x71, 0x9e,
	0x83, 0xc2, 0x0a, 0x73, 0x58, 0x4c, 0x95, 0x8f, 0x1c, 0xd7, 0x3e, 0xc2, 0xd3, 0x40, 0x31, 0x60,
	0xa9, 0x09, 0xe6, 0x77, 0x64, 0xfd, 0x66, 0xc1, 0x67, 0x47, 0x5a, 0xbf, 0x39, 0x05, 0x05, 0x05,
	0xc1, 0xac, 0x08, 0x99, 0xaa, 0x65, 0xfe, 0x25, 0x0b, 0x55, 0xa1, 0x11, 0x0b, 0x6f, 0x38, 0x91,
	0x27, 0x9c, 0xa9, 0x15, 0x06, 0x9e, 0x1d, 0x89, 0xb6, 0x4a, 0x48, 0x1f, 0xea, 0x4c, 0x9c, 0x44,
	0x72, 0x40, 0x2f, 0x41, 0x55, 0xa4, 0xc7, 0x92, 0x01, 0xd7, 0x80, 0x31, 0x5b, 0xb9, 0x34, 0x39,
	0xa0, 0x81, 0x05, 0x9f, 0x29, 0xab, 0x54, 0xf8, 0x4c, 0xfd, 0xe6, 0x1b, 0x30, 0xe5, 0xe1, 0x75,
	0x7b, 0x35, 0xee, 0xbf, 0x3d, 0xdd, 0x16, 0x6b, 0xc2, 0xc3, 0xeb, 0x37, 0xe2, 0x44, 0x80, 0x57,
	0xa0, 0x42, 0x02, 0x37, 0xf4, 0xb1, 0xdd, 0x8a, 0xa3, 0x20, 0x6d, 0x38, 0x90, 0x24, 0x8d, 0x38,
	0x0a, 0xd0, 0xab, 0x50, 0x63, 0x6e, 0xcf, 0xa6, 0xcc, 0xb9, 0x8f, 0xb5, 0x24, 0xe9, 0x72, 0x8e,
	0x49, 0xe6, 0xf6, 0x56, 0x38, 0x99, 0x14, 0xc5, 0xfc, 0xae, 0x76, 0x00, 0x0b, 0xf3, 0xcf, 0xe2,
	0x89, 0xb9, 0x1b, 0x7a, 0xb2, 0x00, 0x35, 0x61, 0x89, 0x67, 0x6e, 0x19, 0xb9, 0x41, 0x56, 0xe9,
	0xba, 0x6a, 0xf5, 0x21, 0x6d, 0xec, 0xbb, 0x08, 0x3d, 0x03, 0x86, 0xde, 0x4b, 0x56, 0x2e, 0x55,
	0xf4, 0xa4, 0x1b, 0x18, 0xeb, 0x3d, 0xfb, 0x2a, 0xc6, 0xe6, 0x1f, 0xb2, 0x0a, 0xf7, 0x8d, 0x30,
	0xf0, 0xd0, 0xe5, 0x04, 0x0b, 0xe9, 0xac, 0xab, 0x66, 0xa3, 0xf3, 0x50, 0x16, 0xd0, 0x18, 0x08,
	0xfe, 0x53, 0xca, 0xac, 0x9c, 0xaf, 0x08, 0xf8, 0xa5, 0x96, 0x7a, 0xe2, 0xf2, 0xf3, 0xa8, 0x12,
	0xec, 0x2d, 0x3f, 0xdb, 0x5c, 0x0a, 0x50, 0x13, 0xaa, 0x1c, 0xb7, 0x3b, 0xf6, 0x1e, 0xd5, 0xc6,
	0xc5, 0x07, 0x12, 0xe8, 0x6b, 0xb1, 0x04, 0xba, 0x94, 0x4c, 0xfd, 0x5c, 0xa0, 0xde, 0xfd, 0x79,
	0xf9, 0xde, 0x05, 0xd7, 0x4d, 0x96, 0x04, 0xce, 0x46, 0xc7, 0xdd, 0x26, 0x54, 0x85, 0xa8, 0x83,
	0x01, 0x7d, 0x34, 0xae, 0x9c, 0x8d, 0x4e, 0x98, 0xfe, 0x9d, 0x4d, 0xcc, 0x79, 0x28, 0x45, 0x26,
	0xaa, 0xc9, 0x1e, 0x48, 0x35, 0xc6, 0x58, 0x54, 0xf3, 0x75, 0xa8, 0x85, 0x1d, 0xcf, 0xde, 0xa1,
	0x9e, 0x91, 0x95, 0x3e, 0x19, 0x76, 0xbc, 0x46, 0x5f, 0x43, 0x9c, 0x79, 0x80, 0x37, 0xec, 0xf1,
	0xe8, 0x7e, 0x32, 0xc0, 0x1b, 0x03, 0xcc, 0xcd, 0x7f, 0x65, 0xa0, 0x78, 0xd3, 0xa1, 0x22, 0x76,
	0x3f, 0xa2, 0xb5, 0xee, 0x1d, 0x05, 0x6d, 0xe3, 0x80, 0x05, 0xed, 0x1d, 0xb5, 0x44, 0x43, 0xd5,
	0x12, 0xcd, 0xcb, 0x50, 0x12, 0x98, 0xbb, 0xe9, 0x50, 0x74, 0x0e, 0xf2, 0x3c, 0x62, 0xd2, 0x7a,
	0x66, 0x47, 0x50, 0x55, 0x4a, 0x51, 0xe0, 0x91, 0x53, 0xcc, 0xef, 0x65, 0x92, 0xc8, 0x2e, 0xce,
	0x1a, 0xd0, 0x5d, 0x38, 0xf1, 0x39, 0xc7, 0x0e, 0x4a, 0x81, 0x4f, 0x28, 0x56, 0x6a, 0xf2, 0x62,
	0x7f, 0x82, 0xe2, 0x8a, 0xa2, 0xa1, 0x91, 0xb4, 0xab, 0xee, 0x4d, 0x38, 0x25, 0xab, 0x7b, 0xee,
	0x1a, 0xf6, 0xe2, 0x0e, 0xf6, 0xee, 0xc4, 0xac, 0x15, 0xf2, 0x78, 0x78, 0x01, 0x0a, 0xb2, 0xa6,
	0xa4, 0xa4, 0xa8, 0x29, 0x29, 0x9a, 0x9b, 0x77, 0x62, 0xb6, 0xc4, 0xb0, 0xaf, 0x3f, 0x49, 0x14,
	0x96, 0xcc, 0x45, 0xb5, 0x5f, 0x59, 0xc1, 0x6e, 0x1c, 0xf1, 0x5c, 0xb7, 0x06, 0x86, 0x4f, 0xdb,
	0xd2, 0xfb, 0x2c, 0xfe, 0x88, 0xce, 0x42, 0x76, 0x1f, 0x79, 0xb2, 0x6c, 0xd3, 0xfc, 0x49, 0x06,
	0x40, 0x72, 0xe9, 0x38, 0x74, 0xed, 0x08, 0x93, 0x80, 0x97, 0xa0, 0x4a, 0xf9, 0x2b, 0xec, 0x64,
	0xe1, 0xdd, 0x67, 0x21, 0x14, 0x33, 0x55, 0xfd, 0xe0, 0x7d, 0xbd, 0x6a, 0x5c, 0x8f, 0x22, 0x87,
	0x39, 0xe3, 0xae, 0x0e, 0x5d, 0xd6, 0x20, 0x1a, 0x16, 0x68, 0x39, 0xf4, 0x1a, 0x35, 0x2e, 0xd0,
	0x47, 0x7f, 0x9d, 0x29, 0xa9, 0x0e, 0xaa, 0x01, 0xf5, 0xfb, 0x8c, 0x42, 0xe2, 0x11, 0x54, 0xac,
	0xd4, 0x2a, 0x96, 0xdd, 0x6f, 0x15, 0xdb, 0x5d, 0x23, 0x34, 0x0e, 0x5a, 0x23, 0xe4, 0x2e, 0x21,
	0x01, 0x94, 0x00, 0xb0, 0x09, 0x25, 0x81, 0xe0, 0xfe, 0x97, 0x7c, 0x65, 0x7b, 0x6b, 0xa6, 0xb0,
	0x14, 0x8c, 0xf4, 0x2d, 0x05, 0x0e, 0xf7, 0x25, 0x2f, 0x05, 0x08, 0x3f, 0xc8, 0xa8, 0xed, 0x5b,
	0x93, 0xd2, 0xd7, 0x70, 0xaf, 0x8d, 0x83, 0x95, 0xd8, 0x75, 0x79, 0x04, 0x7d, 0x0d, 0x8a, 0xdd,
	0xb8, 0x65, 0xdf, 0xc7, 0x3d, 0x25, 0xd0, 0xa5, 0x07, 0x5b, 0x33, 0x73, 0x69, 0xc5, 0xb8, 0x1b,
	0xb7, 0x5e, 0xc3, 0x3d, 0xab, 0xd0, 0x15, 0xbf, 0xa8, 0x0e, 0x45, 0x1f, 0xfb, 0x2d, 0x1c, 0x49,
	0x63, 0x97, 0x2d, 0xdd, 0xe4, 0x59, 0x87, 0x3a, 0x9c, 0x90, 0x5b, 0x68, 0xd5, 0x32, 0x7f, 0x36,
	0x24, 0xd8, 0x0d, 0x87, 0x74, 0xe2, 0x08, 0xa3, 0x19, 0x10, 0x35, 0x7e, 0x55, 0xcd, 0x57, 0x3e,
	0x07, 0xbc, 0x4b, 0x96, 0xf1, 0xd1, 0xff, 0x01, 0x10, 0xca, 0x6d, 0xe3, 0x3a, 0x54, 0x06, 0xce,
	0x92, 0x55, 0x26, 0xf4, 0x9e, 0xec, 0xe0, 0xf4, 0xad, 0x8e, 0xe3, 0x63, 0x9b, 0x8b, 0xcc, 0xad,
	0xc7, 0xe5, 0x01, 0xd1, 0x75, 0x9b, 0xf7, 0xf0, 0xf0, 0x17, 0x71, 0xa3, 0xc8, 0x8c, 0xcd, 0x92,
	0x8d, 0x01, 0x41, 0xf3, 0x3b, 0x04, 0xfd, 0x61, 0x46, 0x1d, 0x93, 0x25, 0x82, 0x2e, 0x63, 0x16,
	0x11, 0x77, 0xbc, 0x0a, 0x3c, 0x0f, 0xc8, 0xc7, 0x1e, 0x71, 0x02, 0xdb, 0x8b, 0x23, 0x87, 0x91,
	0x30, 0xb0, 0x7d, 0xaa, 0x52, 0xe8, 0x9a, 0x1c, 0xb9, 0xa6, 0x06, 0x96, 0x29, 0x77, 0xdc, 0x41,
	0xe5, 0x51, 0xd2, 0xd6, 0x42, 0x8d, 0xd9, 0x5d, 0x0e, 0x26, 0xd6, 0x87, 0x19, 0x98, 0xea, 0x47,
	0x3c, 0x51, 0x26, 0x19, 0xca, 0x2d, 0x32, 0x63, 0xc9, 0x2d, 0x9e, 0xd6, 0x21, 0x4f, 0x95, 0x67,
	0xa4, 0x44, 0x32, 0xb8, 0xa9, 0xf2, 0x4c, 0x3f, 0xdd, 0x35, 0x06, 0xd3, 0x5d, 0x73, 0x0d, 0x4e,
	0x27, 0x3b, 0xb3, 0x86, 0xd3, 0x71, 0x02, 0x17, 0x2f, 0xae, 0x39, 0x41, 0x1b, 0x7b, 0xe8, 0x45,
	0x10, 0xfb, 0x04, 0xdb, 0x15, 0x6d, 0x15, 0xa9, 0x77, 0x87, 0x2d, 0xe9, 0x5b, 0xc0, 0x27, 0x4a,
	0xba, 0xbd, 0x12, 0x6b, 0xf3, 0xe7, 0x3a, 0x0a, 0x2c, 0x93, 0x80, 0x89, 0x84, 0xff, 0x22, 0x14,
	0x68, 0xdc, 0xed, 0x76, 0x24, 0x62, 0x26, 0x93, 0xc5, 0x50, 0x4f, 0x58, 0x11, 0x83, 0x22, 0xbf,
	0x55, 0x13, 0x39, 0x58, 0x3d, 0x1c, 0x84, 0xbe, 0xe2, 0x2d, 0x1b, 0x03, 0x09, 0xa1, 0x71, 0xa0,
	0x84, 0xb0, 0x2f, 0x6a, 0x6e, 0x87, 0xa8, 0xbf, 0x32, 0xa0, 0x2e, 0x01, 0x15, 0x39, 0x1e, 0x5e,
	0x70, 0x45, 0x46, 0x70, 0x4d, 0x1d, 0xe9, 0x8d, 0x9a, 0x7d, 0x26, 0xa9, 0x53, 0x76, 0xfc, 0xa9,
	0xd3, 0x50, 0x25, 0xc5, 0x18, 0x57, 0x25, 0xe5, 0xa8, 0xce, 0x28, 0x12, 0xcf, 0xcc, 0x8f, 0xe5,
	0xf4, 0xfe, 0xd7, 0x06, 0x3c, 0x31, 0x64, 0xb1, 0xa4, 0xbe, 0xfa, 0xd8, 0x64, 0x8f, 0xa0, 0xc9,
	0xfe, 0x93, 0x55, 0x4e, 0x26, 0xd2, 0x4a, 0xec, 0x09, 0xed, 0x1c, 0xd6, 0xc9, 0x9e, 0xdb, 0xd7,
	0x62, 0x2a, 0xab, 0x7d, 0x6c, 0x00, 0x61, 0x80, 0xff, 0x66, 0x95, 0xcf, 0x0c, 0x1a, 0xe0, 0xd0,
	0x3e, 0xf3, 0xd8, 0x02, 0xe9, 0x2d, 0xf0, 0x91, 0xbe, 0x73, 0x64, 0xdd, 0xbb, 0x7d, 0x9d, 0xaf,
	0xa8, 0x1a, 0xfe, 0xcd, 0x5d, 0xf2, 0x8f, 0x9e, 0x26, 0xec, 0x53, 0xb0, 0xcf, 0x1e, 0xb8, 0x60,
	0xff, 0x25, 0xc8, 0x1f, 0x64, 0x0f, 0x20, 0x27, 0xa3, 0xeb, 0x5a, 0x69, 0xd2, 0x0a, 0xcf, 0x8f,
	0xa8, 0xac, 0x5f, 0xe4, 0x54, 0x96, 0xa7, 0x95, 0x95, 0x40, 0xf5, 0x68, 0xb4, 0xb5, 0xfb, 0xcc,
	0x2b, 0x3b, 0x7c, 0xe6, 0xb5, 0x4b, 0xa1, 0xc6, 0xe8, 0x0a, 0xcd, 0x8d, 0xa4, 0xd0, 0xfc, 0x61,
	0x14, 0x8a, 0xe6, 0xe0, 0x84, 0xa3, 0x6f, 0x43, 0xd8, 0xea, 0x53, 0x19, 0x15, 0x67, 0x25, 0x86,
	0x75, 0x3c, 0x19, 0x6a, 0x88, 0x0f, 0x66, 0x14, 0x2d, 0x41, 0xad, 0x3f, 0x5f, 0x7d, 0x72, 0xba,
	0xf3, 0xb3, 0xa9, 0x84, 0x4e, 0x7d, 0xf7, 0xb7, 0xe0, 0xf8, 0x00, 0xab, 0xc3, 0x1f, 0xb0, 0xf6,
	0x05, 0xd3, 0x45, 0xab, 0x7f, 0xe4, 0x54, 0xb6, 0x79, 0x2b, 0x74, 0x82, 0x3b, 0x5d, 0x1c, 0xa0,
	0xd7, 0x61, 0xda, 0x0d, 0x3b, 0x1d, 0x87, 0xe1, 0xc8, 0xe9, 0xd8, 0xea, 0x82, 0x16, 0x4e, 0x5b,
	0x6a, 0x3f, 0xd1, 0xa7, 0xbd, 0xa6, 0x49, 0x51, 0x08, 0xb5, 0x01, 0x96, 0xe3, 0x4f, 0x15, 0xa6,
	0xfa, 0xdc, 0xe5, 0xd9, 0xe5, 0x9b, 0x70, 0xba, 0xdf, 0x45, 0xbe, 0x2d, 0xb7, 0x20, 0x62, 0xc3,
	0x91, 0x12, 0x7c, 0xa7, 0x86, 0xc8, 0x2d, 0xfe, 0x97, 0x23, 0xd9, 0xc3, 0x2d, 0x66, 0x13, 0x4a,
	0x63, 0xec, 0xa5, 0x2d, 0xde, 0x73, 0x92, 0x25, 0x41, 0x81, 0x96, 0x20, 0x1f, 0x6e, 0x04, 0x38,
	0x3a, 0xcc, 0x19, 0x9e, 0xe4, 0x80, 0xda, 0x50, 0xd5, 0xd7, 0x18, 0x93, 0x13, 0xde, 0x71, 0x69,
	0xb4, 0x22, 0x39, 0x4b, 0x6d, 0x26, 0xd1, 0xbc, 0x38, 0x96, 0x68, 0xfe, 0x1b, 0x7d, 0x63, 0x92,
	0x43, 0xce, 0xc2, 0x5d, 0xa7, 0xe7, 0xe3, 0x80, 0xed, 0xc2, 0xdd, 0x86, 0x0a, 0x5a, 0xc1, 0xc1,
	0x71, 0xa7, 0xe3, 0x5d, 0xf0, 0xc5, 0xe3, 0x4e, 0xc3, 0x23, 0xc2, 0x5d, 0x87, 0xa4, 0x3d, 0x1f,
	0x12, 0xf0, 0xb0, 0x04, 0x45, 0x1f, 0x1e, 0xb9, 0x43, 0xc3, 0x63, 0xcc, 0x56, 0xfb, 0x50, 0xdf,
	0xc6, 0x68, 0xbe, 0x7a, 0xc7, 0xba, 0xed, 0xf8, 0x18, 0x21, 0xc8, 0x89, 0xeb, 0x5a, 0xb2, 0xd4,
	0x22, 0x9e, 0xd1, 0x4d, 0xc8, 0x0b, 0x66, 0x6a, 0xd1, 0xd4, 0x6b, 0x4b, 0xaa, 0x97, 0x2d, 0xf2,
	0x01, 0x4b, 0xd2, 0xa3, 0x65, 0x28, 0x8e, 0x21, 0xdb, 0xd1, 0x3c, 0x78, 0x4c, 0x8e, 0x70, 0x9b,
	0x50, 0xa6, 0xca, 0x11, 0xe9, 0xef, 0x37, 0x4e, 0x0d, 0xd2, 0xdd, 0xc0, 0x18, 0xbd, 0x0c, 0x25,
	0x71, 0x06, 0xe8, 0xf8, 0x69, 0xaf, 0xfa, 0x14, 0xf9, 0xfc, 0x05, 0x5f, 0xec, 0xa3, 0xf1, 0x66,
	0x97, 0x44, 0x58, 0x2d, 0x1e, 0xaa, 0xc5, 0xb5, 0x26, 0xad, 0x5e, 0x1c, 0x75, 0x45, 0x96, 0xf4,
	0xe6, 0x4b, 0x49, 0x05, 0x9a, 0x2d, 0x13, 0x9f, 0x44, 0xa8, 0x06, 0x46, 0x52, 0x69, 0xb2, 0xf8,
	0x23, 0x9a, 0x86, 0xfc, 0xba, 0xd3, 0x89, 0xb1, 0xae, 0x0c, 0x88, 0x86, 0x79, 0x4f, 0x5d, 0x09,
	0x5b, 0xc1, 0xec, 0x76, 0xe8, 0xe1, 0x03, 0x11, 0xa3, 0xfa, 0x2e, 0x5b, 0x25, 0x6a, 0x37, 0x67,
	0x55, 0x8d, 0xff, 0x0d, 0x1c, 0x51, 0x12, 0x06, 0x7c, 0xe6, 0xba, 0x7c, 0x54, 0x5c, 0x75, 0xd3,
	0xfc, 0xa7, 0x3e, 0xbb, 0x5a, 0xd9, 0x20, 0xcc, 0x5d, 0x7b, 0x9c, 0x56, 0x7f, 0x01, 0x69, 0xf5,
	0xfb, 0x59, 0x38, 0x21, 0xeb, 0xcd, 0x5d, 0x1c, 0x39, 0x2c, 0x8c, 0xac, 0x90, 0x39, 0x0c, 0xa3,
	0x25, 0x28, 0x50, 0xd2, 0xe6, 0x78, 0x1c, 0x39, 0x43, 0x54, 0x0c, 0x86, 0xea, 0x78, 0xd9, 0xb1,
	0xd4, 0xf1, 0xbe, 0x01, 0xb5, 0x50, 0x89, 0x7c, 0xf8, 0xd3, 0xc7, 0x29, 0xcd, 0x4a, 0xa7, 0x44,
	0xbf, 0x4c, 0x4a, 0xb7, 0x8b, 0x6f, 0x5f, 0xe3, 0xae, 0x4f, 0x5a, 0x31, 0x77, 0xfe, 0x47, 0x74,
	0xb7, 0x61, 0xfe, 0x31, 0xab, 0x23, 0xf3, 0xe2, 0xdb, 0x8b, 0x1d, 0x87, 0xf8, 0x43, 0xf8, 0xcb,
	0x8c, 0x09, 0x7f, 0x57, 0x01, 0x98, 0xdb, 0x3b, 0x98, 0xa4, 0x65, 0xe6, 0xf6, 0x54, 0x36, 0x6b,
	0x01, 0x74, 0x2e, 0x8e, 0xc3, 0xdb, 0xca, 0x9d, 0x8b, 0x43, 0x77, 0x78, 0x73, 0x63, 0x2f, 0x3d,
	0x99, 0x1f, 0x64, 0xfa, 0x8a, 0x15, 0xd7, 0x26, 0x06, 0x57, 0xa5, 0xcc, 0x18, 0x56, 0xa5, 0xcb,
	0x3b, 0x6e, 0xbd, 0xa4, 0x0e, 0x72, 0xe6, 0x8f, 0x75, 0xc5, 0xbc, 0xb9, 0xf8, 0xf6, 0xbd, 0x80,
	0x3e, 0x42, 0xa2, 0x9d, 0xbb, 0x00, 0xd3, 0x9f, 0x77, 0xd3, 0x0e, 0x15, 0xc1, 0x70, 0x3c, 0xaf,
	0x76, 0x0c, 0x55, 0xa1, 0xa4, 0x73, 0xbb, 0x5a, 0xe6, 0xdc, 0x2d, 0x28, 0xe9, 0xbb, 0x19, 0x68,
	0x42, 0xdd, 0xdf, 0xe0, 0x89, 0x50, 0xed, 0x18, 0x3a, 0x0e, 0x13, 0xea, 0xa6, 0x0f, 0x8b, 0xa3,
	0x00, 0x7b, 0xb5, 0x0c, 0x9a, 0xda, 0x71, 0xf9, 0xa7, 0x96, 0x4d, 0x48, 0xdc, 0x90, 0xb2, 0x9a,
	0x71, 0x6e, 0x16, 0xd0, 0x70, 0x4d, 0x1c, 0x95, 0x20, 0xe7, 0x93, 0x80, 0xd5, 0x8e, 0xf1, 0xa7,
	0x56, 0x1c, 0x05, 0xb5, 0x4c, 0xe3, 0xd6, 0xc7, 0xdb, 0x67, 0x32, 0x9f, 0x6c, 0x9f, 0xc9, 0x7c,
	0xba, 0x7d, 0x26, 0xf3, 0xde, 0x67, 0x67, 0x8e, 0x7d, 0xf2, 0xd9, 0x99, 0x63, 0x7f, 0xfa, 0xec,
	0xcc, 0xb1, 0x77, 0x2e, 0x3d, 0x54, 0x65, 0x9b, 0x83, 0xfd, 0xdc, 0xb5, 0x5b, 0x05, 0xf1, 0xcf,
	0x6e, 0x2f, 0xfc, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xbc, 0xf3, 0xc7, 0xbb, 0x8f, 0x37, 0x00, 0x00,
}

func (m *PoolMod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetAdd {
		i--
		if m.AssetAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.RuneAdd {
		i--
		if m.RuneAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.RuneAmt.Size()
		i -= size
		if _, err := m.RuneAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLimitSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLimitSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLimitSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventModifyLimitSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModifyLimitSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModifyLimitSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ModifiedTargetAmount.Size()
		i -= size
		if _, err := m.ModifiedTargetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventStreamingSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStreamingSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventStreamingSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedSwapReasons) > 0 {
		for iNdEx := len(m.FailedSwapReasons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedSwapReasons[iNdEx])
			copy(dAtA[i:], m.FailedSwapReasons[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailedSwapReasons[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FailedSwaps) > 0 {
		dAtA7 := make([]byte, len(m.FailedSwaps)*10)
		var j6 int
		for _, num := range m.FailedSwaps {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintTypeEvents(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.Out.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.In.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TradeTarget.Size()
		i -= size
		if _, err := m.TradeTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.LastHeight != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PoolSlip.Size()
		i -= size
		if _, err := m.PoolSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.StreamingSwapCount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapCount))
		i--
		dAtA[i] = 0x58
	}
	if m.StreamingSwapQuantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapQuantity))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.EmitAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.OutTxs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LiquidityFeeInRune.Size()
		i -= size
		if _, err := m.LiquidityFeeInRune.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.LiquidityFee.Size()
		i -= size
		if _, err := m.LiquidityFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SwapSlip.Size()
		i -= size
		if _, err := m.SwapSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwapTarget.Size()
		i -= size
		if _, err := m.SwapTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventAffiliateFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAffiliateFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAffiliateFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FeeAmount.Size()
		i -= size
		if _, err := m.FeeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.FeeBps != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.FeeBps))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.GrossAmount.Size()
		i -= size
		if _, err := m.GrossAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Thorname) > 0 {
		i -= len(m.Thorname)
		copy(dAtA[i:], m.Thorname)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Thorname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAddLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAddLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAddLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.EmitRune.Size()
		i -= size
		if _, err := m.EmitRune.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.EmitAsset.Size()
		i -= size
		if _, err := m.EmitAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Asymmetry.Size()
		i -= size
		if _, err := m.Asymmetry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPendingLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPendingLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPendingLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PendingType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.PendingType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDonate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDonate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDonate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TcyStakeReward.Size()
		i -= size
		if _, err := m.TcyStakeReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.IncomeBurn.Size()
		i -= size
		if _, err := m.IncomeBurn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.DevFundReward.Size()
		i -= size
		if _, err := m.DevFundReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PoolRewards) > 0 {
		for iNdEx := len(m.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.BondReward.Size()
		i -= size
		if _, err := m.BondReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRefund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRefund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRefund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBond) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBond) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BondAddress) > 0 {
		i -= len(m.BondAddress)
		copy(dAtA[i:], m.BondAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.BondAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BondType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BondType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventReBond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReBond) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReBond) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewBondAddress) > 0 {
		i -= len(m.NewBondAddress)
		copy(dAtA[i:], m.NewBondAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NewBondAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OldBondAddress) > 0 {
		i -= len(m.OldBondAddress)
		copy(dAtA[i:], m.OldBondAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.OldBondAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GasPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.RuneAmt.Size()
		i -= size
		if _, err := m.RuneAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventReserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReserveContributor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventScheduledOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventScheduledOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventScheduledOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OutTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlashAmount) > 0 {
		for iNdEx := len(m.SlashAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.Pool.Size()
		i -= size
		if _, err := m.Pool.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventErrata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventErrata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventErrata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.InTxID) > 0 {
		i -= len(m.InTxID)
		copy(dAtA[i:], m.InTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.InTxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenSuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenSuccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenSuccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Round) > 0 {
		i -= len(m.Round)
		copy(dAtA[i:], m.Round)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Round)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BlameNodes) > 0 {
		for iNdEx := len(m.BlameNodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BlameNodes[iNdEx])
			copy(dAtA[i:], m.BlameNodes[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.BlameNodes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsUnicast {
		i--
		if m.IsUnicast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FailReason) > 0 {
		i -= len(m.FailReason)
		copy(dAtA[i:], m.FailReason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailReason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeysignMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeysignMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeysignMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlashPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlashPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlashPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.SlashPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPoolBalanceChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPoolBalanceChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPoolBalanceChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.PoolChange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventMintBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMintBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMintBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Supply != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecuredAssetDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecuredAssetDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecuredAssetDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecuredAssetWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecuredAssetWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecuredAssetWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRUNEPoolDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRUNEPoolDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRUNEPoolDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRUNEPoolWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRUNEPoolWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRUNEPoolWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AffiliateAddress) > 0 {
		i -= len(m.AffiliateAddress)
		copy(dAtA[i:], m.AffiliateAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AffiliateAddress)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.AffiliateAmount.Size()
		i -= size
		if _, err := m.AffiliateAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.AffiliateBasisPts != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.AffiliateBasisPts))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Units.Size()
		i -= size
		if _, err := m.Units.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventLoanOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLoanOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLoanOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.TargetAsset.Size()
		i -= size
		if _, err := m.TargetAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.DebtIssued.Size()
		i -= size
		if _, err := m.DebtIssued.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.CollateralizationRatio.Size()
		i -= size
		if _, err := m.CollateralizationRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CollateralAsset.Size()
		i -= size
		if _, err := m.CollateralAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CollateralDeposited.Size()
		i -= size
		if _, err := m.CollateralDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLoanRepayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLoanRepayment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLoanRepayment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.DebtRepaid.Size()
		i -= size
		if _, err := m.DebtRepaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.CollateralAsset.Size()
		i -= size
		if _, err := m.CollateralAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CollateralWithdrawn.Size()
		i -= size
		if _, err := m.CollateralWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTHORName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTHORName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTHORName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Expire != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.FundAmt.Size()
		i -= size
		if _, err := m.FundAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RegistrationFee.Size()
		i -= size
		if _, err := m.RegistrationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetNodeMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetNodeMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetNodeMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventOperatorRotate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOperatorRotate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOperatorRotate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTCYDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTCYDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTCYDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTCYClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTCYClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTCYClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Asset.Size()
		i -= size
		if _, err := m.Asset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.L1Address) > 0 {
		i -= len(m.L1Address)
		copy(dAtA[i:], m.L1Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.L1Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.TcyAmount.Size()
		i -= size
		if _, err := m.TcyAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTCYStake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTCYStake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTCYStake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTCYUnstake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTCYUnstake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTCYUnstake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypeEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypeEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PoolMod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.RuneAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.RuneAdd {
		n += 2
	}
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.AssetAdd {
		n += 2
	}
	return n
}

func (m *EventLimitSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Source.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Target.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventModifyLimitSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Source.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Target.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ModifiedTargetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventStreamingSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovTypeEvents(uint64(m.Interval))
	}
	if m.Quantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.Quantity))
	}
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	if m.LastHeight != 0 {
		n += 1 + sovTypeEvents(uint64(m.LastHeight))
	}
	l = m.TradeTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Deposit.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.In.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Out.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.FailedSwaps) > 0 {
		l = 0
		for _, e := range m.FailedSwaps {
			l += sovTypeEvents(uint64(e))
		}
		n += 1 + sovTypeEvents(uint64(l)) + l
	}
	if len(m.FailedSwapReasons) > 0 {
		for _, s := range m.FailedSwapReasons {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFeeInRune.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.OutTxs.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.StreamingSwapQuantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapQuantity))
	}
	if m.StreamingSwapCount != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapCount))
	}
	l = m.PoolSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventAffiliateFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Thorname)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.GrossAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.FeeBps != 0 {
		n += 1 + sovTypeEvents(uint64(m.FeeBps))
	}
	l = m.FeeAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventAddLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.Asymmetry.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitRune.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPendingLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.PendingType != 0 {
		n += 1 + sovTypeEvents(uint64(m.PendingType))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventDonate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypeEvents(uint64(m.Status))
	}
	return n
}

func (m *PoolAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Amount != 0 {
		n += 1 + sovTypeEvents(uint64(m.Amount))
	}
	return n
}

func (m *EventRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BondReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.PoolRewards) > 0 {
		for _, e := range m.PoolRewards {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = m.DevFundReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.IncomeBurn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.TcyStakeReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventRefund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypeEvents(uint64(m.Code))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventBond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BondType != 0 {
		n += 1 + sovTypeEvents(uint64(m.BondType))
	}
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.BondAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventReBond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.OldBondAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.NewBondAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *GasPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.RuneAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	return n
}

func (m *EventGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventReserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReserveContributor.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventScheduledOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.SlashAmount) > 0 {
		for _, e := range m.SlashAmount {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventErrata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTssKeygenSuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FailReason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.IsUnicast {
		n += 2
	}
	if len(m.BlameNodes) > 0 {
		for _, s := range m.BlameNodes {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = len(m.Round)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventTssKeysignMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventSlashPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.SlashPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.SlashPoints))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventPoolBalanceChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PoolChange.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventMintBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Supply != 0 {
		n += 1 + sovTypeEvents(uint64(m.Supply))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSecuredAssetDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSecuredAssetWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventRUNEPoolDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventRUNEPoolWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Units.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.AffiliateBasisPts != 0 {
		n += 1 + sovTypeEvents(uint64(m.AffiliateBasisPts))
	}
	l = m.AffiliateAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AffiliateAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventLoanOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralDeposited.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralizationRatio.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.DebtIssued.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.TargetAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventLoanRepayment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralWithdrawn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.DebtRepaid.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTHORName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RegistrationFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.FundAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Expire != 0 {
		n += 1 + sovTypeEvents(uint64(m.Expire))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetNodeMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventOperatorRotate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTCYDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTCYClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.TcyAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.L1Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTCYStake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTCYUnstake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func sovTypeEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypeEvents(x uint64) (n int) {
	return sovTypeEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PoolMod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuneAdd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssetAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLimitSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLimitSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLimitSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModifyLimitSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModifyLimitSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModifyLimitSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedTargetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModifiedTargetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStreamingSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStreamingSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStreamingSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TradeTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.In.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Out.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FailedSwaps = append(m.FailedSwaps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypeEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypeEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FailedSwaps) == 0 {
					m.FailedSwaps = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypeEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FailedSwaps = append(m.FailedSwaps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwaps", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwapReasons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedSwapReasons = append(m.FailedSwapReasons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFeeInRune", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFeeInRune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTxs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapQuantity", wireType)
			}
			m.StreamingSwapQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapQuantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapCount", wireType)
			}
			m.StreamingSwapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAffiliateFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAffiliateFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAffiliateFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thorname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thorname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrossAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GrossAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeBps", wireType)
			}
			m.FeeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeBps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAddLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAddLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asymmetry", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asymmetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitRune", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitRune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPendingLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPendingLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPendingLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingType", wireType)
			}
			m.PendingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingType |= PendingLiquidityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDonate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDonate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDonate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PoolStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolRewards = append(m.PoolRewards, PoolAmt{})
			if err := m.PoolRewards[len(m.PoolRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevFundReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DevFundReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomeBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncomeBurn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcyStakeReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TcyStakeReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRefund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRefund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRefund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
			}
			m.BondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BondType |= BondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondAddress = append(m.BondAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.BondAddress == nil {
				m.BondAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReBond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReBond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReBond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldBondAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldBondAddress = append(m.OldBondAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.OldBondAddress == nil {
				m.OldBondAddress = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBondAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewBondAddress = append(m.NewBondAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NewBondAddress == nil {
				m.NewBondAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, GasPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveContributor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReserveContributor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventScheduledOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventScheduledOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventScheduledOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAmount = append(m.SlashAmount, PoolAmt{})
			if err := m.SlashAmount[len(m.SlashAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventErrata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventErrata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventErrata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, PoolMod{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InTxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenSuccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_thorchain_thornode_v3_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnicast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnicast = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlameNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlameNodes = append(m.BlameNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_thorchain_thornode_v3_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeysignMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeysignMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeysignMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlashPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlashPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlashPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPoints", wireType)
			}
			m.SlashPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPoolBalanceChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMintBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMintBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMintBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= MintBurnSupplyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecuredAssetDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecuredAssetDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecuredAssetDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecuredAssetWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecuredAssetWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecuredAssetWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRUNEPoolDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRUNEPoolDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRUNEPoolDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = append(m.RuneAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RuneAddress == nil {
				m.RuneAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRUNEPoolWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRUNEPoolWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRUNEPoolWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = append(m.RuneAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RuneAddress == nil {
				m.RuneAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Units.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateBasisPts", wireType)
			}
			m.AffiliateBasisPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffiliateBasisPts |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AffiliateAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AffiliateAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLoanOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLoanOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLoanOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralizationRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralizationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtIssued", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtIssued.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLoanRepayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLoanRepayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLoanRepayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtRepaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtRepaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTHORName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTHORName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTHORName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = gitlab_com_thorchain_thornode_v3_common.Chain(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetNodeMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetNodeMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetNodeMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_v3_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOperatorRotate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOperatorRotate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOperatorRotate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = append(m.Signer[:0], dAtA[iNdEx:postIndex]...)
			if m.Signer == nil {
				m.Signer = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = append(m.OperatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.OperatorAddress == nil {
				m.OperatorAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTCYDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTCYDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTCYDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = append(m.RuneAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.RuneAddress == nil {
				m.RuneAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTCYClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTCYClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTCYClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcyAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TcyAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.L1Address = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTCYStake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTCYStake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTCYStake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTCYUnstake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTCYUnstake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTCYUnstake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_thorchain_thornode_v3_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypeEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypeEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypeEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypeEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypeEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypeEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypeEvents = fmt.Errorf("proto: unexpected end of group")
)
